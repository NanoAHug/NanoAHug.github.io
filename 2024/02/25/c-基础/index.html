

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="4Cc3">
  <meta name="keywords" content="">
  
    <meta name="description" content="自从学了c++逆向之后我才发现原来我只会c with stl, 因此在这里记录一些高级c++的基础知识。   面向对象1. 友元  友元函数可以访问类中的private和protect成员，声明友元函数只需要在类中添加friend关键字与待声明函数的原型, 例如现有如下函数原型:  1234567891011121314ostream &amp;operator&lt;&lt;(ostream &amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="高级C++基础">
<meta property="og:url" content="https://nanoahug.github.io/2024/02/25/c-%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="4Cc3&#39;s Blog">
<meta property="og:description" content="自从学了c++逆向之后我才发现原来我只会c with stl, 因此在这里记录一些高级c++的基础知识。   面向对象1. 友元  友元函数可以访问类中的private和protect成员，声明友元函数只需要在类中添加friend关键字与待声明函数的原型, 例如现有如下函数原型:  1234567891011121314ostream &amp;operator&lt;&lt;(ostream &amp;">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-02-25T08:57:16.000Z">
<meta property="article:modified_time" content="2024-11-26T07:44:59.657Z">
<meta property="article:author" content="4Cc3">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>高级C++基础 - 4Cc3&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"nanoahug.github.io","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"|","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>4Cc3&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="高级C++基础"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-02-25 16:57" pubdate>
          February 25, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.3k words
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          37 mins
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">高级C++基础</h1>
            
            
              <div class="markdown-body">
                
                <p>自从学了c++逆向之后我才发现原来我只会c with stl, 因此在这里记录一些高级c++的基础知识。  </p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="1-友元"><a href="#1-友元" class="headerlink" title="1. 友元"></a>1. 友元</h3><p>  友元函数可以访问类中的private和protect成员，声明友元函数只需要在类中添加<code>friend</code>关键字与待声明函数的原型, 例如现有如下函数原型:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, complex a)<br>&#123;<br>  out&lt;&lt;a.m_real&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;a.m_imag&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br>```  <br>该函数是一个输出流运算符重载函数, 我们将他定义在类的外部, 但是这么做就会面临一个问题, 那就是无法输出类中的私有变量, 此时我们就需要对其添加友元属性:  <br><br>```C++<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;<br>  ...<br>  <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, complex a);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><br>  上述代码会在类中将重载函数定义为友元函数, 此时该函数就相当于Complex类中定义的函数了。</p>
<h3 id="2-构造函数与拷贝构造函数"><a href="#2-构造函数与拷贝构造函数" class="headerlink" title="2. 构造函数与拷贝构造函数"></a>2. 构造函数与拷贝构造函数</h3><p>构造函数的形式是  </p>
<figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-keyword">class</span> <span class="hljs-title class_">classname</span>&#123;<br><br>  <span class="hljs-title function_">classname</span>(<span class="hljs-params">typename</span> <span class="hljs-params">var</span>)&#123;<br>    <span class="hljs-comment">//code</span><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个东西是干啥的呢, 比如你有一个代码为<code>classname a=3.14</code>, 那么编译器就会报错, 因为它不知道怎么把一个浮点数赋值给classname, 所以这个时候就需要你在类中定义这么一个构造函数, 来指定赋值时发生的行为。需要注意的是，在声明了一个构造函数后，你的所有<code>=</code>运算符也自动被重载了， 即你想写<code>a=3.14;</code>时，不用额外再写个<code>classname operator=(typename var)&#123;&#125;</code>这么个东西了。</p>
<p>并且，所有的类在声明时会自动带一个构造函数，这个自带的构造函数是用来处理同类型变量的，假如你有一个classname类型的对象QAQ，那么你想在声明阶段声明一个classname类型的AWA，并且想把这个QAQ的初始值设置为和AWA一样，那么直接写<code>classname AWA=QAQ;</code>即可，不需要重新再写一个构造函数(赋值时也是一样的)，但是假如你想让这个过程发生一些额外的行为，例如你想让AWA等于两倍的QAQ再减一，你就需要对构造函数进行一下重构，编译器自动生成的构造函数只能单纯的进行一次拷贝。</p>
<p>如果一个构造函数没有参数, 那么在对象创建时会自动调用, 如果有参数, 那么就需要用<code>classname var(par);</code>这种语句。</p>
<p>在栈上创建对象时，实参位于对象名后面，例如<code>Student stu(&quot;小明&quot;, 15, 92.5f)；</code>在堆上创建对象时，实参位于类名后面，例如<code>new Student(&quot;李华&quot;, 16, 96);</code>。</p>
<p>构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处。</p>
<p>构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。  </p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-comment">//声明运算符重载</span><br>	<span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> real, <span class="hljs-type">double</span> imag): <span class="hljs-built_in">m_real</span>(real), <span class="hljs-built_in">m_imag</span>(imag)&#123; &#125;<br><br>	<br>	<span class="hljs-built_in">complex</span>(<span class="hljs-type">int</span> a)&#123;<br>		m_real=<span class="hljs-number">0.0</span>,<br>		m_imag=<span class="hljs-number">0.0</span>;<br>	&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  complex a;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>那么此时编译器就会报错（因为类中包含了构造函数，而创建对象时却没有调用。），但是把构造函数删掉，编译器就会使用默认的构造函数，反而不会报错了。或者也可以自己手动再添加没有参数的构造函数：<code>complex()&#123;&#125;;</code></p>
<p>如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。</p>
<p>一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。</p>
<p>最后需要注意的一点是，调用没有参数的构造函数也可以省略括号。<code>complex a;</code>和<code>complex a();</code>是一样的。</p>
<p>拷贝构造函数的形式是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">T</span> (<span class="hljs-type">const</span> T&amp; other_obj)&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 const 引用。构造函数的形参必须是引用，但不限制为const，但普遍来说会加上const限制。</p>
<p>为什么必须是当前类的引用呢？<br>如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。</p>
<p>为什么是 const 引用呢？<br>拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。</p>
<p>另外一个原因是，添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非 const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为 const 类型不能转换为非 const 类型，这就意味着，不能使用 const 对象来初始化当前对象了。</p>
<p>拷贝构造函数会在以下三种情况中被调用:  </p>
<ol>
<li>用类的一个对象去初始化类的另一个对象时  </li>
<li>如果函数的形参是类的对象, 调用函数时, 进行形参和实参结合(实参是caller传入的东西, 形参是放在寄存器或栈上的, callee分配的东西)</li>
<li>如果函数的返回值是类的对象, 函数执行完成返回时(返回时, callee会将要返回的对象拷贝给一个临时变量, 然后销毁callee中的对象, 回到caller的位置再将对象当做返回值返回)</li>
</ol>
<h3 id="3-初始化列表"><a href="#3-初始化列表" class="headerlink" title="3. 初始化列表"></a>3. 初始化列表</h3><p>  在写构造函数时, 不仅可以将成员变量在构造函数的函数体中赋值, 也可以将成员变量用初始化列表赋值, 初始化列表的书写方法如下:  </p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> real, <span class="hljs-type">double</span> imag): <span class="hljs-built_in">m_real</span>(real), <span class="hljs-built_in">m_imag</span>(imag)&#123; &#125;<br><span class="hljs-built_in">complex</span>()&#123;<br>  m_real=<span class="hljs-number">0.0</span>,<br>  m_imag=<span class="hljs-number">0.0</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">double</span> m_real;  <span class="hljs-comment">//实部</span><br>  <span class="hljs-type">double</span> m_imag;  <span class="hljs-comment">//虚部</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>  上述代码中, 两个构造函数的功能类似, 但是采取了两个不同的写法, 第一个构造函数在函数声明和函数体之间多了一个冒号和一个用逗号连接的列表, 具体用法是<code>变量名(表达式)[,变量名(表达式)...]</code><br>  该语句等价于 <code>变量名=表达式</code></p>
<h2 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h2><p>C++中的引用(reference)使用符号”&amp;”表示, 这个东西看着和C中的取地址符是同一个符号, 但是这两个的作用却不相同, 在C++中引用相当于是一个变量的别名, 使用引用定义的变量和其原变量没有任何区别。  </p>
<p>例如： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> la;<br><span class="hljs-type">int</span> &amp;a = la;<br></code></pre></td></tr></table></figure>

<p>使用该定义, 则变量a就是la, 操作a和操作la是一样的, c++在编译时会自动进行优化, 对a的所有操作都会变成直接对la的操作。</p>
<p>引用的应用有以下几点：</p>
<h3 id="1-做为函数参数"><a href="#1-做为函数参数" class="headerlink" title="1. 做为函数参数"></a>1. 做为函数参数</h3><p>在当做参数时，应用的参数可以直接操作传入的数字，而不是操作传入参数的拷贝<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>a+=<span class="hljs-number">0xcafe</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello_pointer</span><span class="hljs-params">(<span class="hljs-type">int</span> *a)</span></span>&#123;<br>*a+=<span class="hljs-number">0xfe</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello_ref</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span>&#123;<br>  a+=<span class="hljs-number">0xca</span>;	<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>  <span class="hljs-built_in">hello</span>(a);<br>  <span class="hljs-built_in">hello_pointer</span>(&amp;a);<br>  <span class="hljs-built_in">hello_ref</span>(a);<br>&#125;    <br><br></code></pre></td></tr></table></figure></p>
<p>上面的三个函数的反编译结果分别是</p>
  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs x86ASM">      <span class="hljs-comment">; void __fastcall hello()</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span>                               <span class="hljs-meta">public</span> _Z5helloi<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span>                               _Z5helloi proc <span class="hljs-built_in">near</span>                     <span class="hljs-comment">; CODE XREF: main+19↓p</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span>                                                                       <span class="hljs-comment">; DATA XREF: .pdata:000000014000506C↓o</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span>                               arg_0= <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">10h</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span> <span class="hljs-number">55</span>                            <span class="hljs-keyword">push</span>    <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001531</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> E5                      <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001534</span> <span class="hljs-number">89</span> <span class="hljs-number">4D</span> <span class="hljs-number">10</span>                      <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rbp</span>+arg_0], <span class="hljs-built_in">ecx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001537</span> <span class="hljs-number">81</span> <span class="hljs-number">45</span> <span class="hljs-number">10</span> FE CA <span class="hljs-number">00</span> <span class="hljs-number">00</span>          <span class="hljs-keyword">add</span>     [<span class="hljs-built_in">rbp</span>+arg_0], <span class="hljs-number">0CAFEh</span><br><span class="hljs-symbol">.text:</span>000000014000153E <span class="hljs-number">90</span>                            <span class="hljs-keyword">nop</span><br><span class="hljs-symbol">.text:</span>000000014000153F <span class="hljs-number">5D</span>                            <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001540</span> C3                            <span class="hljs-keyword">retn</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001540</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001540</span>                               _Z5helloi endp<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001540</span><br></code></pre></td></tr></table></figure>
<p>hello 这个函数中, ecx中存放参数, 可见函数中新建了一个变量arg_0用来存放参数, 说明函数调用的参数是一个拷贝<br>  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs x86ASM">      <span class="hljs-comment">; int *__fastcall hello_pointer(int *)</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                               <span class="hljs-meta">public</span> _Z13hello_pointerPi<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                               _Z13hello_pointerPi proc <span class="hljs-built_in">near</span>           <span class="hljs-comment">; CODE XREF: main+25↓p</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                                                                       <span class="hljs-comment">; DATA XREF: .pdata:000000014000506C↓o</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                                                                       <span class="hljs-comment">; .pdata:0000000140005078↓o</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                               arg_0= <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">10h</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span> <span class="hljs-number">55</span>                            <span class="hljs-keyword">push</span>    <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001542</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> E5                      <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001545</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4D</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rbp</span>+arg_0], <span class="hljs-built_in">rcx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001549</span> <span class="hljs-number">48</span> 8B <span class="hljs-number">45</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+arg_0]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000154D</span> 8B <span class="hljs-number">00</span>                         <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">rax</span>]<br><span class="hljs-symbol">.text:</span>000000014000154F <span class="hljs-number">8D</span> <span class="hljs-number">90</span> FE <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>             <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">edx</span>, [<span class="hljs-built_in">rax</span>+<span class="hljs-number">0FEh</span>]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001555</span> <span class="hljs-number">48</span> 8B <span class="hljs-number">45</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+arg_0]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001559</span> <span class="hljs-number">89</span> <span class="hljs-number">10</span>                         <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rax</span>], <span class="hljs-built_in">edx</span><br><span class="hljs-symbol">.text:</span>000000014000155B <span class="hljs-number">90</span>                            <span class="hljs-keyword">nop</span><br><span class="hljs-symbol">.text:</span>000000014000155C <span class="hljs-number">5D</span>                            <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000155D</span> C3                            <span class="hljs-keyword">retn</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000155D</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000155D</span>                               _Z13hello_pointerPi endp<br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000155D</span><br></code></pre></td></tr></table></figure></p>
<p>  hello_pointer函数中, rcx是调用变量的地址, 而寻址后改变的是传入的原变量,能够起到改变传入的变量的效果  </p>
  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs x86ASM">          <span class="hljs-keyword">int</span> *__fastcall hello_ref(<span class="hljs-keyword">int</span> *)<br><span class="hljs-symbol">.text:</span>000000014000155E                               <span class="hljs-meta">public</span> _Z9hello_refRi<br><span class="hljs-symbol">.text:</span>000000014000155E                               _Z9hello_refRi proc <span class="hljs-built_in">near</span>                <span class="hljs-comment">; CODE XREF: main+31↓p</span><br><span class="hljs-symbol">.text:</span>000000014000155E                                                                       <span class="hljs-comment">; DATA XREF: .pdata:0000000140005078↓o</span><br><span class="hljs-symbol">.text:</span>000000014000155E                                                                       <span class="hljs-comment">; .pdata:0000000140005084↓o</span><br><span class="hljs-symbol">.text:</span>000000014000155E<br><span class="hljs-symbol">.text:</span>000000014000155E                               arg_0= <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">10h</span><br><span class="hljs-symbol">.text:</span>000000014000155E<br><span class="hljs-symbol">.text:</span>000000014000155E <span class="hljs-number">55</span>                            <span class="hljs-keyword">push</span>    <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span>000000014000155F <span class="hljs-number">48</span> <span class="hljs-number">89</span> E5                      <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001562</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4D</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rbp</span>+arg_0], <span class="hljs-built_in">rcx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001566</span> <span class="hljs-number">48</span> 8B <span class="hljs-number">45</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+arg_0]<br><span class="hljs-symbol">.text:</span>000000014000156A 8B <span class="hljs-number">00</span>                         <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">rax</span>]<br><span class="hljs-symbol">.text:</span>000000014000156C <span class="hljs-number">8D</span> <span class="hljs-number">90</span> CA <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>             <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">edx</span>, [<span class="hljs-built_in">rax</span>+<span class="hljs-number">0CAh</span>]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001572</span> <span class="hljs-number">48</span> 8B <span class="hljs-number">45</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+arg_0]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001576</span> <span class="hljs-number">89</span> <span class="hljs-number">10</span>                         <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rax</span>], <span class="hljs-built_in">edx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001578</span> <span class="hljs-number">90</span>                            <span class="hljs-keyword">nop</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001579</span> <span class="hljs-number">5D</span>                            <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span>000000014000157A C3                            <span class="hljs-keyword">retn</span><br><span class="hljs-symbol">.text:</span>000000014000157A<br><span class="hljs-symbol">.text:</span>000000014000157A                               _Z9hello_refRi endp<br><br></code></pre></td></tr></table></figure>
<p>  而hello_ref函数传参是一个引用, 观察代码, 可以发现, 使用引用和使用指针传参是同样的效果,代码完全相同, 这就说明引用其实是编辑器代替你操作指针, 只不过使用引用将会减少代码量并提高代码可读性。  </p>
<p>指针与引用的区别：</p>
<ul>
<li>指针是可以独立存在的; 但是引用不行</li>
<li>引用必须要进行初始化，指针没有必要</li>
<li>指针可以设置为NULL， 但是引用不行</li>
<li>引用一旦进行初始化之后，不会再改变其指向；但指针可以</li>
</ul>
<h3 id="2-引用作为函数的返回值"><a href="#2-引用作为函数的返回值" class="headerlink" title="2. 引用作为函数的返回值"></a>2. 引用作为函数的返回值</h3><p>  语法：类型 &amp;函数名（形参列表）{ 函数体 }<br>  1.引用作为函数的返回值时，必须在定义函数时在函数名前加&amp;<br>  2.用引用作函数的返回值的最大的好处是在内存中不产生返回值的副本</p>
<p>  例如:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">func</span>(<span class="hljs-number">0</span>) = <span class="hljs-number">10</span>;<span class="hljs-comment">// 若func的返回值是一个生命周期大于func的变量时</span><br><span class="hljs-type">int</span> &amp;a = <span class="hljs-built_in">func</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></p>
<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="1-重载一般运算符"><a href="#1-重载一般运算符" class="headerlink" title="1. 重载一般运算符"></a>1. 重载一般运算符</h3><p>  这里的一般运算符指普通的二元运算符, 例如加减乘除<br>  以下列程序为例:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> real, <span class="hljs-type">double</span> imag): <span class="hljs-built_in">m_real</span>(real), <span class="hljs-built_in">m_imag</span>(imag)&#123; &#125;<br>  <span class="hljs-built_in">complex</span>()&#123;<br>    m_real=<span class="hljs-number">0.0</span>,<br>    m_imag=<span class="hljs-number">0.0</span>;<br>  &#125;<br><br><br>  complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> complex &amp;A) <span class="hljs-type">const</span>&#123;<br>    complex B;<br>    B.m_real = <span class="hljs-keyword">this</span>-&gt;m_real + A.m_real;<br>    B.m_imag = <span class="hljs-keyword">this</span>-&gt;m_imag + A.m_imag;<br>    <span class="hljs-keyword">return</span> B;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">double</span> m_real;  <span class="hljs-comment">//实部</span><br>  <span class="hljs-type">double</span> m_imag;  <span class="hljs-comment">//虚部</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">complex::display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>  cout&lt;&lt;m_real&lt;&lt;<span class="hljs-string">&quot; + &quot;</span>&lt;&lt;m_imag&lt;&lt;<span class="hljs-string">&quot;i&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">4.3</span>, <span class="hljs-number">5.8</span>)</span></span>;<br>  <span class="hljs-function">complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2.4</span>, <span class="hljs-number">3.7</span>)</span></span>;<br>  complex c3;<br>  c3 = c1 + c2;<br>  c3.<span class="hljs-built_in">display</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>  仔细观察上面的程序, 我们在 complex 类中重载了运算符+，该重载只对 complex 对象有效, 当执行c3 &#x3D; c1 + c2;语句时，编译器检测到+号左边（+号具有左结合性，所以先检测左边）是一个 complex 对象，就会调用成员函数operator+()，也就是转换为下面的形式：<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">c3 = c1.<span class="hljs-keyword">operator</span>+(c2);<br></code></pre></td></tr></table></figure><br>  c1 是要调用函数的对象，c2 是函数的实参。<br>  当然, 上述写法是重载了一个成员函数, 对于运算符的重载也可以变为全局重载:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> complex &amp;A, <span class="hljs-type">const</span> complex &amp;B)&#123;<br>  complex C;<br>  C.m_real = A.m_real + B.m_real;<br>  C.m_imag = A.m_imag + B.m_imag;<br>  <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><br>  当编译器检测到调用时,例如 <strong>c3&#x3D;c1+c2</strong> 加号两边都是complex类型的变量, 那么编译器就会使用如下的调用<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">c3=<span class="hljs-keyword">operator</span>+(c1,c2);<br></code></pre></td></tr></table></figure><br>  <font size=5>将运算符重载函数作为类的成员函数时，二元运算符的参数只有<strong>一个</strong>，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的,默认就是this。</font>  </p>
<h3 id="2-输入输出流运算符重载"><a href="#2-输入输出流运算符重载" class="headerlink" title="2. 输入输出流运算符重载"></a>2. 输入输出流运算符重载</h3><p>  一般来说, 这类运算符都是在类外部借用友元函数重载的, 具体原因是因为如果在类内部重载, 那么就需要先将对象实例化, 再通过对象来调用运算符, 例如<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Distance</span><br>&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> feet;             <span class="hljs-comment">// 0 到无穷</span><br>        <span class="hljs-type">int</span> inches;           <span class="hljs-comment">// 0 到 12</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// 所需的构造函数</span><br>        <span class="hljs-built_in">Distance</span>()&#123;<br>            feet = <span class="hljs-number">0</span>;<br>            inches = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">Distance</span>(<span class="hljs-type">int</span> f, <span class="hljs-type">int</span> i)&#123;<br>            feet = f;<br>            inches = i;<br>        &#125;<br>        ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream &amp; os)<br>        &#123;<br>            os&lt;&lt;<span class="hljs-string">&quot;英寸：&quot;</span>&lt;&lt;feet&lt;&lt;<span class="hljs-string">&quot;\n英尺：&quot;</span>&lt;&lt;inches;<br>            <span class="hljs-keyword">return</span> os;<br>        &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Distance <span class="hljs-title">d1</span><span class="hljs-params">(<span class="hljs-number">20</span>,<span class="hljs-number">18</span>)</span></span>;<br>    d1&lt;&lt;cout;<span class="hljs-comment">//相当于d1.operator&lt;&lt;(cout)</span><br>&#125;<br>```  <br>这里的就是通过成员函数进行声明, 在使用时, 运算符左值必须为对象。     <br>若不使用成员函数进行重载， 那么就该使用<span class="hljs-keyword">friend</span>关键字先在类中声明函数为友元函数  <br><br>```C++<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br>  ...<br>  <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out , complex a);<br>  ...<br><br>&#125;<br><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, complex a)<br>&#123;<br>  out&lt;&lt;a.m_real&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;a.m_imag&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure></p>
<p>  而返回一个ostream的对象的原因是方便其可以在返回后继续进行输出or输入, 函数的定义也可以看到返回的是一个ostream类型的引用。而这个第一个参数其实是cout这个对象，而cout是在std中定义的对象。  </p>
<h3 id="3-重载-运算符"><a href="#3-重载-运算符" class="headerlink" title="3. 重载[]运算符"></a>3. 重载[]运算符</h3><p>  C++ 规定，下标运算符[ ]必须以成员函数的形式进行重载。该重载函数在类中的声明格式如下：<code>返回值类型 &amp; operator[ ] (参数);</code></p>
<p>  或者：<code>const 返回值类型 &amp; operator[ ] (参数) const; </code></p>
<p>  使用第一种声明方式，[ ]不仅可以访问元素，还可以修改元素。使用第二种声明方式，[ ]只能访问而不能修改元素。在实际开发中，我们应该同时提供以上两种形式，这样做是为了适应 const 对象，因为通过 const 对象只能调用 const 成员函数，如果不提供第二种形式，那么将无法访问 const 对象的任何元素。</p>
<h3 id="4-重载-运算符"><a href="#4-重载-运算符" class="headerlink" title="4. 重载++ --运算符"></a>4. 重载++ --运算符</h3><p>  这两个都是一元运算符，重载方式如下：<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">complex <span class="hljs-keyword">operator</span>++()&#123;<br>  m_real++;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<span class="hljs-comment">//++i</span><br><br>complex <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> n)&#123;<br>  complex s = *<span class="hljs-keyword">this</span>;<br>  m_real++;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<span class="hljs-comment">//i++</span><br></code></pre></td></tr></table></figure><br>  可以看到, 返回值是表达式的结果(基本上所有运算符重载的返回值都是表达式的结果)  </p>
<p>  而前自增和后自增的区别为是否传参, 后自增的参数<code>int n</code>没有任何意义</p>
<h3 id="5-C-重载-（强制类型转换运算符）"><a href="#5-C-重载-（强制类型转换运算符）" class="headerlink" title="5. C++重载()（强制类型转换运算符）"></a>5. C++重载()（强制类型转换运算符）</h3><p>在 C++ 中，类型的名字（包括类的名字）本身也是一种运算符，即类型强制转换运算符。</p>
<p>  类型强制转换运算符是单目运算符，也可以被重载，但只能<em>重载为成员函数</em>，<em>不能重载为全局函数</em>。经过适当重载后，<code>(类型名)对象</code>这个对对象进行强制类型转换的表达式就等价于<code>对象.operator 类型名()</code>，即变成对运算符函数的调用。</p>
<p>  对类型转化定义过的函数，编译器会在需要时自动调用，例如  </p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;<br>...<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> real; &#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>  这个函数就对double()这个强制转换进行了定义, 需要注意的是, <em>对double运算符重载不需要指定返回类型</em>, 因为返回类型就是重载运算符本身代表的类型, 即为double</p>
<p>  定义之后, 在本该出现 double 类型的变量或常量的地方，如果出现了一个 Complex 类型的对象，那么该对象的 operator double 成员函数就会被调用，然后取其返回值使用。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Complex <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">1.2</span>, <span class="hljs-number">3.4</span>)</span></span>;<br>cout &lt;&lt; (<span class="hljs-type">double</span>)c &lt;&lt; endl;  <span class="hljs-comment">//输出 1.2</span><br><span class="hljs-type">double</span> n = <span class="hljs-number">2</span> + c;  <span class="hljs-comment">//等价于 double n = 2 + c. operator double()</span><br>cout &lt;&lt; n;  <span class="hljs-comment">//输出 3.2</span><br></code></pre></td></tr></table></figure>



<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="1-C-const相关"><a href="#1-C-const相关" class="headerlink" title="1. C++ const相关"></a>1. C++ const相关</h3><ul>
<li><p>const成员变量  </p>
<p>const成员变量非常好定义, 只需要在定义时在最前面加上const关键字即可, 定义为const的变量无法更改其值  </p>
</li>
<li><p>const成员函数  </p>
<p>常成员函数的定义方法为在函数的最后加一个const关键字, 例如:  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Student::getage</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>  <span class="hljs-keyword">return</span> m_age;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个代码中, getage函数加了const关键字, 那么其对所有成员变量的访问权限就变为了只读<br>需要注意的是, 加了const的和不加const的函数是两个完全不同的函数原型。<br>还有需要注意的事是，如果const关键字被加在了一个函数的最开头， 那么就说明该函数的返回值是一个常量， 不允许修改其返回值  </p>
</li>
<li><p>常对象<br>  定义常对象的语法和定义常量的语法类似：          </p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-keyword">class</span> <span class="hljs-title">object</span><span class="hljs-params">(params)</span></span>;  <br><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-type">const</span> <span class="hljs-title">object</span><span class="hljs-params">(params)</span></span>;  <br><span class="hljs-type">const</span> <span class="hljs-keyword">class</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">class</span>(params);<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">const</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">class</span>(params);<br></code></pre></td></tr></table></figure>
<p> class为类名，object为对象名，params为实参列表， p为指针名。两种方式定义出来的对象都是常对象。 </p>
<p> 一旦将对象定义为常对象之后，不管是哪种形式，该对象就只能访问被 const 修饰的成员了（包括 const 成员变量和 const 成员函数），因为非 const 成员可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。</p>
</li>
</ul>
<h2 id="2-static关键字"><a href="#2-static关键字" class="headerlink" title="2. static关键字"></a>2. static关键字</h2><p>  声明为static的变量会存储在bss段或者data段，而不是在栈中，因此当一个函数的执行周期结束后并不会被释放掉，同时static不会破坏类的封装性，类外不能访问protect和private的变量。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BC%96%E7%A8%8B/" class="category-chain-item">编程</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/C/" class="print-no-link">#C++</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>高级C++基础</div>
      <div>https://nanoahug.github.io/2024/02/25/c-基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>4Cc3</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>February 25, 2024</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/03/04/IDA%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8/" title="IDA交叉引用">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">IDA交叉引用</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/02/24/C-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/" title="C++逆向工程">
                        <span class="hidden-mobile">C++逆向工程</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
