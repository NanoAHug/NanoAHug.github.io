<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++23漫谈</title>
    <link href="/2024/12/14/C++23%EF%BC%9A%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/"/>
    <url>/2024/12/14/C++23%EF%BC%9A%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>鸽了相当长时间的C++编程，这期间尝试了python、go、C#，最终还是觉得C++是经久不衰的编程语言，  </p><p>最开始我觉得C++开发效率太低，各种新特性非常复杂，学习难度很高，有这时间去学点Go，学点python，能用很短的时间就做出来各种各样精美的项目。  </p><p>但是在见证了各种生成式人工智能的威力后，我还是屈服了。越简单的东西就越会受到AI的冲击，因此我对于AI时代的认知就是一定要尝试更加复杂，更加困难，人烟稀少的方向，用于对抗生成式人工智能对人类社会的冲击。  </p><h1 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="多维下表运算符"><a href="#多维下表运算符" class="headerlink" title="多维下表运算符"></a>多维下表运算符</h1><p>在23中，访问数组可以像C#那样访问，直接在一个括号内进行</p><pre><code class="C++">#include &lt;iostream&gt;using namespace std;int v[3][1] = &#123;&#123;1&#125;, &#123;2&#125;, &#123;3&#125;&#125;;int main() &#123;    std::cout &lt;&lt; v[0, 0] &lt;&lt; endl;    std::cout &lt;&lt; v[0][0]&lt;&lt;endl;    std::cout &lt;&lt; *v[0, 0] &lt;&lt; endl;&#125;/*0x7ff60f20300011*/</code></pre><p>直接使用[, …]的方式访问数组只会得到一个指针地址，如果想要获取到值还需要解引用  </p><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go：Context上下文杂谈</title>
    <link href="/2024/12/09/Go%EF%BC%9AContex%E4%B8%8A%E4%B8%8B%E6%96%87%E6%9D%82%E8%B0%88/"/>
    <url>/2024/12/09/Go%EF%BC%9AContex%E4%B8%8A%E4%B8%8B%E6%96%87%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<p>很多项目中都会很频繁的见到Contex这个概念, 不难发现它实际上并没有明确指代某一个有具体定义的数据结构。上下文实际上是一个非常通用的概念, 通常来讲, context可以指代某一个特定的环境, 例如在操作系统中的context就可以指寄存器当时所存储的值, 在项目开发中context可以指项目根路径  </p><p>这里以go语言举例, 在做web开发时, 会经常用到gin.contex, 这里的上下文会携带前端传入的各种请求信息, 例如请求头、请求体、认证信息等.  </p><p>在API之间的相互调用时经常会用到Go语言提供的Contex这个标准库  </p><p>contex常常是在客户端对服务端发起请求时创建, 在Go语言官方文档中, 常常要求开发者将Contex作为函数的第一个参数, 命名为ctx(这里的函数指API调用链上的函数). </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoSomething</span><span class="hljs-params">(ctx context.Context, arg Arg)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// ... use ctx ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>换句话说, Context发挥作用的场景大多数是需要跟踪请求超时, 取消信号, 以及在调用链中传递元数据的场景(在传递数据时,官方说明不应该传递业务逻辑相关的数据, 所以元数据传递实际上也用的少)  </p><p>这里举几个例子用于描述</p><p>Case1: 带取消的上下文</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(ctx context.Context, name <span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-keyword">select</span> &#123;<br>        <span class="hljs-keyword">case</span> &lt;-ctx.Done():<br>            fmt.Printf(<span class="hljs-string">&quot;%s: received cancel signal, stopping...\n&quot;</span>, name)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">default</span>:<br>            fmt.Printf(<span class="hljs-string">&quot;%s: working...\n&quot;</span>, name)<br>            time.Sleep(<span class="hljs-number">500</span> * time.Millisecond)<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    ctx, cancel := context.WithCancel(context.Background())<br><br>    <span class="hljs-comment">// 启动两个子任务</span><br>    <span class="hljs-keyword">go</span> worker(ctx, <span class="hljs-string">&quot;worker-1&quot;</span>)<br>    <span class="hljs-keyword">go</span> worker(ctx, <span class="hljs-string">&quot;worker-2&quot;</span>)<br><br>    <span class="hljs-comment">// 主任务执行两秒后，取消所有子任务</span><br>    time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>    fmt.Println(<span class="hljs-string">&quot;main: cancelling context...&quot;</span>)<br>    cancel()  <span class="hljs-comment">// 这里发出取消信号，子任务将收到并停止</span><br><br>    <span class="hljs-comment">// 给子任务一点时间完成清理</span><br>    time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>case2: 带超时的上下文  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">2</span> * time.Second): <span class="hljs-comment">// 模拟一个需要很长时间的操作</span><br>        fmt.Println(<span class="hljs-string">&quot;Finished task&quot;</span>)<br>    <span class="hljs-keyword">case</span> &lt;-ctx.Done(): <span class="hljs-comment">// 当上下文取消或超时，进入这里</span><br>        fmt.Println(<span class="hljs-string">&quot;Task cancelled due to timeout:&quot;</span>, ctx.Err())<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个有 1 秒超时的 context</span><br>    ctx, cancel := context.WithTimeout(context.Background(), <span class="hljs-number">1</span>*time.Second)<br>    <span class="hljs-keyword">defer</span> cancel() <span class="hljs-comment">// 确保 context 在退出前被取消</span><br><br>    doSomething(ctx)<br>&#125;<br><br><span class="hljs-string">``</span><span class="hljs-string">`  </span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">Case3: 使用上下文传递元数据  </span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>Go<br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>    userID := ctx.Value(<span class="hljs-string">&quot;userID&quot;</span>)<br>    <span class="hljs-keyword">if</span> userID == <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;No user ID found&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;Processing request for user ID: %v\n&quot;</span>, userID)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个包含 userID 的 context</span><br>    ctx := context.WithValue(context.Background(), <span class="hljs-string">&quot;userID&quot;</span>, <span class="hljs-number">12345</span>)<br><br>    <span class="hljs-comment">// 将 context 传递到下游函数</span><br>    processRequest(ctx)<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>同时, 上下文之间还存在父子关系, 上下文可以从父上下文中创建, 当父上下文取消后子上下文也会跟着取消.  </p><p>这里的”父子关系”实际上更像是一种嵌套, 父上下文不能访问子上下文中的值,但是反过来可以, 上下文的传播是单向的, 这里举例说明  </p><p>创建一个带取消并且带值的上下文  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processRequest</span><span class="hljs-params">(ctx context.Context)</span></span> &#123;<br>    <span class="hljs-comment">// 提取 userID</span><br>    userID := ctx.Value(<span class="hljs-string">&quot;userID&quot;</span>)<br>    <span class="hljs-keyword">if</span> userID == <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;No user ID found&quot;</span>)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-comment">// 模拟一个需要时间的任务</span><br>    <span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">2</span> * time.Second): <span class="hljs-comment">// 模拟任务耗时2秒</span><br>        fmt.Printf(<span class="hljs-string">&quot;Processing request for user ID: %v completed\n&quot;</span>, userID)<br>    <span class="hljs-keyword">case</span> &lt;-ctx.Done(): <span class="hljs-comment">// 超时或取消信号</span><br>        fmt.Println(<span class="hljs-string">&quot;Request cancelled or timed out:&quot;</span>, ctx.Err())<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 创建一个带有超时的 context，设置为 1 秒</span><br>    ctx, cancel := context.WithTimeout(context.Background(), <span class="hljs-number">1</span>*time.Second)<br>    <span class="hljs-keyword">defer</span> cancel() <span class="hljs-comment">// 确保 context 在退出前被取消，防止资源泄漏</span><br><br>    <span class="hljs-comment">// 在超时的 context 基础上，添加一个 userID</span><br>    ctx = context.WithValue(ctx, <span class="hljs-string">&quot;userID&quot;</span>, <span class="hljs-number">12345</span>)<br><br>    <span class="hljs-comment">// 处理请求</span><br>    processRequest(ctx)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里就通过嵌套让上下文的机制可以更加复杂, 可以看到在processRequest中传递了上下文, 并且在函数中子上下文可以使用父上下文中的取消信号</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
      <tag>开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杂谈：Python 遭遇 ProxyError 问题记录</title>
    <link href="/2024/12/09/%E8%B0%88%EF%BC%9APython-%E9%81%AD%E9%81%87-ProxyError-%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/12/09/%E8%B0%88%EF%BC%9APython-%E9%81%AD%E9%81%87-ProxyError-%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>在使用低版本python安装包的时候，一直会出现下面的错误  </p><p><img src="/images/pasted-93.png" alt="upload successful">  </p><p>这里这个很让人沮丧，排查了很多原因都没有找到问题的源头，发现只有使用python3.13的版本才不会报错，最后在网上找到一篇文章溯源了这个报错  </p><p><a href="https://zhuanlan.zhihu.com/p/350015032">点击跳转</a>    </p><p>这里主要是因为urllib3 更新之后，启用了HTTPS的支持，但是我使用的代理软件V2RayN并没有HTTPS，这也就导致了pip在安装包的时候不能正确建立HTTPS连接，使得SSL握手错误，因此导致了这个问题  </p><p>那么这个问题最后文章中给出的方案是直接更改系统中的代理设置，将HTTPS的请求也使用HTTP的代理  </p><p><code>http=http://127.0.0.1:10809;https=http://127.0.0.1:10809</code></p><p>但是如果使用v2rayN的话，使用自动配置系统代理时会清除掉之前设置过的代理。所以这里的解决方案为直接更改系统代理的配置，并且v2rayN选则清除系统代理即可。  </p><p>对于需要过滤掉的国内网页，也可以直接在windows自带的代理设置中设置</p><p><img src="/images/pasted-95.png" alt="upload successful">  </p><p>这里使用正则语法    </p><p>当然，有些时候还会遇到在命令行中的流量不走代理的情况，一般解决方法是在环境变量中配置HTTP_PROXY和HTTPS_PROXY，如果不想让环境变量过于复杂，也可以选择直接在windows自带的系统代理中设置代理IP地址，这么设置之后一般也能解决</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>杂谈: 记录一次docker+mysql环境配置</title>
    <link href="/2024/12/06/%E6%9D%82%E8%B0%88-%E4%BD%BF%E7%94%A8docker%E7%AE%A1%E7%90%86mysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2024/12/06/%E6%9D%82%E8%B0%88-%E4%BD%BF%E7%94%A8docker%E7%AE%A1%E7%90%86mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>最近在做项目开发的时候想要尝试一下把数据库放到docker里进行管理, 这么做的好处我个人认为是迁移方便, 并且有实现那分布式数据库的潜力, 而且在环境配置上也会更加友好, 编写docker compose脚本就可以在本地或者是远程测试服务器上多次部署环境.  </p><p>但是本人近期遇到几个非常弱智的问题, 这里记录一下  </p><p>首先是docker指令问题, 请观赏  </p><pre><code class="bash">NAME=&quot;testmysql&quot;docker run $NAME -d -p 3306:3306 -v ./data:/var/lib/mysql --name $NAME</code></pre><p>一开始我认为没什么问题, 但是这么做会一直报错  </p><pre><code class="text">root@iZ8vbiv2lm756vfo1dru59Z:~/docker/mysql# docker run $NAME -d -p 3306:3306 -v ./data:/var/lib/mysql --name $NAME2024-12-06 08:50:49+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.27-1debian10 started.2024-12-06 08:50:49+00:00 [ERROR] [Entrypoint]: mysqld failed while attempting to check config        command was: mysqld -d -p 3306:3306 -v ./data:/var/lib/mysql --name testmysql --verbose --help --log-bin-index=/tmp/tmp.ISE98xaRN9        Enter password: mysqld: Can not perform keyring migration : Invalid --keyring-migration-source option.2024-12-06T08:50:49.594209Z 0 [ERROR] [MY-011084] [Server] Keyring migration failed.2024-12-06T08:50:49.595600Z 0 [ERROR] [MY-010119] [Server] Abortingroot@iZ8vbiv2lm756vfo1dru59Z:~/docker/mysql# docker run $NAME -d -p 3306:3306 -v --name $NAME2024-12-06 08:51:09+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.27-1debian10 started.2024-12-06 08:51:09+00:00 [ERROR] [Entrypoint]: mysqld failed while attempting to check config        command was: mysqld -d -p 3306:3306 -v --name testmysql --verbose --help --log-bin-index=/tmp/tmp.SKv2zjnLzz        Enter password: mysqld: Can not perform keyring migration : Invalid --keyring-migration-source option.2024-12-06T08:51:09.431278Z 0 [ERROR] [MY-011084] [Server] Keyring migration failed.2024-12-06T08:51:09.432680Z 0 [ERROR] [MY-010119] [Server] Aborting</code></pre><p>这里会出现一个Keyring migration failed.的错误, 然后这就导致我一直把注意力放在这个密钥环上, 无论怎么尝试关闭密钥环都会出现这个问题  </p><p>然后我就绝望了, 只有在输入指令<code>docker run $NAME --name $NAME</code>的时候才能正常启动docker, 但是这样就没有办法端口映射了, 不搞端口映射还玩什么容器化, 于是我又猜测会不会是volume的问题, 如果使用路径映射是不是会出现一些权限上的问题, 于是我又创建了一些volume, 然后使用卷挂载来做持久化的工作</p><pre><code class="text">root@iZ8vbiv2lm756vfo1dru59Z:~/docker/mysql# docker run -p 3306:3306 -v test-mysql-data:/var/lib/mysql $NAME --name $NAME2024-12-06 09:04:27+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.27-1debian10 started.2024-12-06 09:04:27+00:00 [Note] [Entrypoint]: Switching to dedicated user &#39;mysql&#39;2024-12-06 09:04:27+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 8.0.27-1debian10 started.2024-12-06T09:04:27.840127Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.0.27) starting as process 12024-12-06T09:04:27.861770Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started.2024-12-06T09:04:28.242646Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended.mysqld: Table &#39;mysql.plugin&#39; doesn&#39;t exist2024-12-06T09:04:28.385907Z 0 [ERROR] [MY-010735] [Server] Could not open the mysql.plugin table. Please perform the MySQL upgrade procedure.2024-12-06T09:04:28.387093Z 0 [Warning] [MY-010441] [Server] Failed to open optimizer cost constant tables2024-12-06T09:04:28.388126Z 0 [Warning] [MY-010441] [Server] Failed to open optimizer cost constant tables2024-12-06T09:04:28.389071Z 0 [Warning] [MY-010441] [Server] Failed to open optimizer cost constant tables2024-12-06T09:04:28.390062Z 0 [Warning] [MY-010441] [Server] Failed to open optimizer cost constant tables2024-12-06T09:04:28.390955Z 0 [Warning] [MY-010441] [Server] Failed to open optimizer cost constant tables2024-12-06T09:04:28.391898Z 0 [Warning] [MY-010441] [Server] Failed to open optimizer cost constant tables2024-12-06T09:04:28.392796Z 0 [Warning] [MY-010441] [Server] Failed to open optimizer cost constant tables2024-12-06T09:04:28.468809Z 0 [Warning] [MY-010015] [Repl] Gtid table is not ready to be used. Table &#39;mysql.gtid_executed&#39; cannot be opened.2024-12-06T09:04:28.495540Z 0 [Warning] [MY-010015] [Repl] Gtid table is not ready to be used. Table &#39;mysql.gtid_executed&#39; cannot be opened.2024-12-06T09:04:28.500795Z 0 [Warning] [MY-013746] [Server] A deprecated TLS version TLSv1 is enabled for channel mysql_main2024-12-06T09:04:28.500828Z 0 [Warning] [MY-013746] [Server] A deprecated TLS version TLSv1.1 is enabled for channel mysql_main2024-12-06T09:04:28.503691Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed.2024-12-06T09:04:28.503826Z 0 [System] [MY-013602] [Server] Channel mysql_main configured to support TLS. Encrypted connections are now supported for this channel.2024-12-06T09:04:28.506955Z 0 [Warning] [MY-011810] [Server] Insecure configuration for --pid-file: Location &#39;/var/run/mysqld&#39; in the path is accessible to all OS users. Consider choosing a different directory.2024-12-06T09:04:28.508020Z 0 [Warning] [MY-010441] [Server] Failed to open optimizer cost constant tables2024-12-06T09:04:28.508982Z 0 [ERROR] [MY-013129] [Server] A message intended for a client cannot be sent there as no client-session is attached. Therefore, we&#39;re sending the information to the error-log instead: MY-001146 - Table &#39;mysql.component&#39; doesn&#39;t exist2024-12-06T09:04:28.509050Z 0 [Warning] [MY-013129] [Server] A message intended for a client cannot be sent there as no client-session is attached. Therefore, we&#39;re sending the information to the error-log instead: MY-003543 - The mysql.component table is missing or has an incorrect definition.2024-12-06T09:04:28.509719Z 0 [ERROR] [MY-000068] [Server] unknown option &#39;--name&#39;.2024-12-06T09:04:28.510837Z 0 [ERROR] [MY-010119] [Server] Aborting2024-12-06T09:04:29.952664Z 0 [System] [MY-010910] [Server] /usr/sbin/mysqld: Shutdown complete (mysqld 8.0.27)  MySQL Community Server - GPL.root@iZ8vbiv2lm756vfo1dru59Z:~/docker/mysql# docker volume rm test-mysql-dataError response from daemon: remove test-mysql-data: volume is in use - [bf8c7483e99b3d12a70d67ab95e8583560125ecad881ada80696ef4388ef66f1, d9c1d39cbfa9d75e32d06cbda8bc439878bfeaee25b156e6b06a255f8710d202] </code></pre><p>结果还是一直爆这个构思错误, 又给我干奔溃了  </p><p>之前是使用windows上的docker desktop尝试了这么配置mysql环境, 也是一直报错类似的东西, 因此我怀疑是windows上的docker是运行在虚拟机里的, 在权限和存储上或许会有些问题, 于是我切换到linux平台下再次做个实验, 结果还是报这个错误, 当时整个人都不好了  </p><p>结果啊, 最后偶然间注意到, 这个docker的语法上好像有些需要注意的地方  </p><p><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code>  </p><p>牛魔的, 这里这个IMAGE要严格的在run后面, 因为后面是需要传递给镜像内部的指令, 也就是说, 我最开始的指令 </p><p><code>docker run $NAME -d -p 3306:3306 -v ./data:/var/lib/mysql --name $NAME</code>一直出现问题, 其实是因为run $NAME后面的东西都被当成参数传递给镜像里了, 所以才出那么多奇奇怪怪的问题, 这直接给我逗笑了  </p><p>不过这也让我意识到是时候仔细了解docker内部的工作原理了, 多研究下虚拟化技术   </p><p>接下来就是迁移相关的工作, 如果使用volume, 在windows上可能会兼容性不太好, 有可能会找不到volume的具体存储文职, 所以我这里建议使用路劲映射的方式来存储  </p><p>MySQL默认的数据目录是 &#x2F;var&#x2F;lib&#x2F;mysql ，配置文件位于 &#x2F;etc&#x2F;mysql , 所以这里挂载的时候找一个data文件挂载到这里的<code>/var/lib/mysql</code>, 然后data文件中存储的就是数据库的所有文件了, 迁移的时候把这里的data直接迁移走, 然后使用同一个启动脚本, 挂载相同的目录即可(-v .&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql)  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>开发：GO JWT基础使用</title>
    <link href="/2024/12/01/%E5%BC%80%E5%8F%91%EF%BC%9AGO-JWT%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/12/01/%E5%BC%80%E5%8F%91%EF%BC%9AGO-JWT%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>简单记录一下JWT的原理以及使用  </p><h1 id="什么是JWT？"><a href="#什么是JWT？" class="headerlink" title="什么是JWT？"></a>什么是JWT？</h1><p>JWT （JSON Web Token） 是目前最流行的跨域认证解决方案，是一种基于 Token 的认证授权机制。 从 JWT 的全称可以看出，JWT 本身也是 Token，一种规范化之后的 JSON 结构的 Token。  </p><p>JWT的组成有三部分，分别是HEADER、PAYLOAD、SIGNATURE  </p><ul><li><p>header: 用于描述jwt的元数据, 其中最主要的字段是”alg”, 也就是生成签名的算法  </p></li><li><p>payload: 用于存放需要传递的数据, 这一部分中最主要的部分是”Claims”, 也就是声明, 可以用于安全传递信息  </p></li><li><p>signature: 用于存放签名算法生成的内容</p></li></ul><p>也就是说, 只有在知道签名算法, 密钥, 内容不被篡改的情况下, jwt才可以被解析出, 这也就保证了数据传递的安全性, 当我们在做开发的时候, 就可以在前端存放jwt, 在后端进行身份校验  </p><h1 id="在Go语言开发的时候如何使用JWT"><a href="#在Go语言开发的时候如何使用JWT" class="headerlink" title="在Go语言开发的时候如何使用JWT"></a>在Go语言开发的时候如何使用JWT</h1><p>首先介绍一个最常用的库  </p><p><code>github.com/golang-jwt/jwt/v4</code>  </p><p>安装之后就可以使用了  </p><h2 id="生成JWT"><a href="#生成JWT" class="headerlink" title="生成JWT"></a>生成JWT</h2><p>在生成JWT之前, 首先要声明一个结构体, 用于作为jwt的payload部分</p><p>这里的Claim结构是开发者自行定义的, 这里我们选择继承自<code>jwt.RegisteredClaims</code>, 因为Claim对象必须要有一个Valid方法, 我们肯定懒得自己写, 就干脆继承自<code>RegisteredClaims</code>直接用框架的就好了</p><p><code>RegisteredClaims</code>中还有一些标准的jwt的字段, 如果有必要的话可以使用, 但是我们这里选择自己声明字段(因为更方便简单)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> Claim <span class="hljs-keyword">struct</span> &#123;<br>ID        <span class="hljs-type">int</span><br>ExpiresAt <span class="hljs-type">int64</span><br>NotBefore <span class="hljs-type">int64</span><br>jwt.RegisteredClaims<br>&#125;<br></code></pre></td></tr></table></figure><p>除此之外, signKey是一个需要自己指定的密钥, 这个密钥需要有一定强度防止jwt被解析出  </p><p><code>var signKey = []byte(&quot;hahaha&quot;)</code></p><p>接着就可以按照以下方法生成jwt了  </p><pre><code class="Go">// 生成一个token字符串,若出错返回&quot;&quot;func GenerateTokenWithId(id int) (string, error) &#123;    claim := &amp;Claim&#123;        ID:        id,        ExpiresAt: time.Now().Add(1 * 365 * 24 * time.Hour).Unix(), // 设置过期时间为1年后    &#125;    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claim)    tokenString, err := token.SignedString(signKey)    if err != nil &#123;        return &quot;&quot;, err    &#125;    return tokenString, nil&#125;</code></pre><p>可以看到, 这里使用<code>jwt.NewWithClaims</code>生成一个Token对象, 然后再使用<code>SignedString</code>方法对token进行签名, 并返回一个字符串, 这个字符串就是我们需要的jwt了  </p><h2 id="解析JWT"><a href="#解析JWT" class="headerlink" title="解析JWT"></a>解析JWT</h2><p>在解析的时候, 一般会收到一个字符串对象, 我们要做的就是把这个字符串对象解析会一个Claim对象(也就是从token解析出payload)  </p><pre><code class="Go">func ParseToken(tokenString string) (*Claim, error) &#123;    token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface&#123;&#125;, error) &#123;        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok &#123;            return nil, fmt.Errorf(&quot;Unexpected signing method: %v&quot;, token.Header[&quot;alg&quot;])        &#125;        return signKey, nil    &#125;)    if err != nil &#123;        return nil, err    &#125;    if claim, ok := token.Claims.(Claim); ok &amp;&amp; token.Valid &#123;        return &amp;claim, nil    &#125; else &#123;        return nil, fmt.Errorf(&quot;Token invalid&quot;)    &#125;&#125;</code></pre><p>这里主要使用一个Parse函数用于处理token  </p><p>Parse的函数签名如下  </p><p><code>func Parse(tokenString string, keyFunc Keyfunc, options ...ParserOption) (*Token, error)</code>  </p><p>这里的第一个参数很好理解, 主要是第二个参数keyFunc, 它是一个有着固定函数签名的函数, 它的作用是返回密钥(或者是一个生成密钥的函数, 这里看你在NewWithClaims的时候选择什么签名算法)  </p><p>这里的keyFunc可以用于检验jwt头部中的加密算法, 并选择对应的处理方式(例如alg字段是HMAC就返回HMAC密钥,是RSA就返回RSA公钥)  如果检验过程中有错误就返回nil,用于触发异常  </p><p>如果没有什么问题, Parse就会返回一个Token对象, 然后我们要做的就是检验一下这个Token对象,( 比如检查一下类型是否是我们自己声明的Claim, 调用一下Valid函数检验token是否被篡改) 如果没什么问题, 直接返回这个token中的Claims就可以了, 接着后端就可以处理相关的工作了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>开发：使用gRPC进行Go语言开发</title>
    <link href="/2024/11/23/%E5%BC%80%E5%8F%91%EF%BC%9ARPC/"/>
    <url>/2024/11/23/%E5%BC%80%E5%8F%91%EF%BC%9ARPC/</url>
    
    <content type="html"><![CDATA[<p>这里对gRPC的使用过程进行简单的描述  </p><p>首先，需要安装protobuf的编译器protoc，<a href="https://github.com/protocolbuffers/protobuf/releases">下载地址</a>  </p><p>可以将protobuf理解成是一个规范消息传递的语言</p><p>protoc这个编译器是负责将pb语言编译为其它各种语言的，由于原生的编译器没有带Go语言的支持，所以需要安装插件  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">go</span> install google.golang.org/protobuf/cmd/protoc-gen-go@latest<br><span class="hljs-keyword">go</span> install google.golang.org/grpc/cmd/protoc-gen-<span class="hljs-keyword">go</span>-grpc@latest<br><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> google.golang.org/grpc<br><span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> google.golang.org/protobuf<br><br></code></pre></td></tr></table></figure><p>这里前两个是安装Go语言支持的插件，后两个是安装依赖项，由于我们使用的是gRPC，所以不仅需要安装protoc的go支持，还需要安装一个grpc的支持  </p><p>后两个安装的包是go语言的grpc和protobuffer的框架，用于在代码中更好的进行开发  </p><p>接下来就可以编写一个demo尝试使用grpc，首先需要一个proto文件 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs proto">//api.proto<br>syntax = &quot;proto3&quot;;<br><br>package example;<br><br>option go_package = &quot;/apipb&quot;;<br><br>// 定义消息<br>message Request &#123;<br>  string name = 1;<br>&#125;<br><br>message Response &#123;<br>  string message = 1;<br>&#125;<br><br>// 定义服务<br>service Greeter &#123;<br>  rpc SayHello (Request) returns (Response);<br>&#125;<br></code></pre></td></tr></table></figure><p>初学者见到这个proto文件可能会感到陌生，实际上proto很简单，主要分为两个东西，message和service，message规定一个类似结构体的东西，里面可以放任何字段，可以理解为用于组织变量，service用于组织函数  </p><p>在proto前面的package是用于proto间包管理的，你可以import别的proto文件，使用<code>import &quot;user.proto&quot;; </code>这种语法就可以  </p><p>go_package是用于规定生成的go代码的package的,例如此处规定的go_package是”&#x2F;apipb”,那么生成的代码就会放在proto同级目录下的apipb文件夹内，并且生成的go代码的包名会叫做apipb</p><p>接着使用编译器进行编译  </p><p><code>protoc.exe  --go_out=. --go-grpc_out=. api.proto</code></p><p>这样就会编译出两个文件，一个是api.pb.go一个是api_grpc.pb.go  ，这两个模块是分离的，api只负责消息的定义和操作，而api_grpc负责rpc服务的定义方法实现  </p><p>接下来就可以对服务端进行实现  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><br>pb <span class="hljs-string">&quot;RPC/api/apipb&quot;</span> <br><span class="hljs-string">&quot;google.golang.org/grpc&quot;</span><br>)<br><br><span class="hljs-comment">// 定义服务</span><br><span class="hljs-keyword">type</span> greeterServer <span class="hljs-keyword">struct</span> &#123;<br>pb.UnimplementedGreeterServer<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *greeterServer)</span></span> SayHello(ctx context.Context, req *pb.Request) (*pb.Response, <span class="hljs-type">error</span>) &#123;<br>log.Printf(<span class="hljs-string">&quot;Received: %v&quot;</span>, req.Name)<br><span class="hljs-keyword">return</span> &amp;pb.Response&#123;Message: <span class="hljs-string">&quot;Hello &quot;</span> + req.Name&#125;, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lis, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:50051&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Failed to listen: %v&quot;</span>, err)<br>&#125;<br><br>grpcServer := grpc.NewServer()<br>pb.RegisterGreeterServer(grpcServer, &amp;greeterServer&#123;&#125;)<br><br>log.Println(<span class="hljs-string">&quot;Server is listening on :50051&quot;</span>)<br><span class="hljs-keyword">if</span> err := grpcServer.Serve(lis); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;Failed to serve: %v&quot;</span>, err)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里的实现其实是很有讲究的，为什么要这么写呢?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> greeterServer <span class="hljs-keyword">struct</span> &#123;<br>pb.UnimplementedGreeterServer<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>pb.UnimplementedGreeterServer</code>grpc生成的结构体,这个结构体包含了一些方法,这些方法都是编译器自带的方法, 很多情况下不一定会用得到, 但是一定会包含的一个方法就是proto文件中在server中定义的方法, 这里会根据当时编写的规定生成对应签名的函数方法,并生成一个默认值,这里的默认值一般就是生成一个未实现的报错    </p><p>这种写法是为了防止proto文件中添加了新的方法后, 服务端代码会编译错误  </p><p>具体原因如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Go"><br><span class="hljs-keyword">type</span> GreeterServer <span class="hljs-keyword">interface</span> &#123;<br>SayHello(context.Context, *Request) (*Response, <span class="hljs-type">error</span>)<br>mustEmbedUnimplementedGreeterServer()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(UnimplementedGreeterServer)</span></span> SayHello(context.Context, *Request) (*Response, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, status.Errorf(codes.Unimplemented, <span class="hljs-string">&quot;method SayHello not implemented&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> UnimplementedGreeterServer <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterGreeterServer</span><span class="hljs-params">(s grpc.ServiceRegistrar, srv GreeterServer)</span></span> &#123;<br><span class="hljs-comment">// If the following call pancis, it indicates UnimplementedGreeterServer was</span><br><span class="hljs-comment">// embedded by pointer and is nil.  This will cause panics if an</span><br><span class="hljs-comment">// unimplemented method is ever invoked, so we test this at initialization</span><br><span class="hljs-comment">// time to prevent it from happening at runtime later due to I/O.</span><br><span class="hljs-keyword">if</span> t, ok := srv.(<span class="hljs-keyword">interface</span>&#123; testEmbeddedByValue() &#125;); ok &#123;<br>t.testEmbeddedByValue()<br>&#125;<br>s.RegisterService(&amp;Greeter_ServiceDesc, srv)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这是go-gen-grpc这个插件自动生成的go代码, 这个函数是用于注册服务的(注册是将方法的实现和服务的实例绑定到一起,也就是Register<servicename>Server这个生成的函数用的), 可以看到,这里第二个参数srv接受的是一个接口</p><p>这里使用匿名字段, 相当于是greeterServer继承了pb.UnimplementedGreeterServer中的字段, 这样greeterServer就不用实现proto文件中所有定义过的方法了，如果没有重构，那么就会默认调用grpc生成的报错代码</p><p>除此之外，gprc还会为我们生成一个<code>Unsafe&lt;servicename&gt;Server</code>这样的接口，其用法和<code>Unimplemented&lt;servicename&gt;Server</code>类似，只不过Unsafe这种方法会更加自由一些，你可以自定义未完成接口时的行为，但是这个东西一般来说不推荐使用，因为会麻烦</p><p>接下来就是服务的具体方法  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *greeterServer)</span></span> SayHello(ctx context.Context, req *pb.Request) (*pb.Response, <span class="hljs-type">error</span>) &#123;<br>log.Printf(<span class="hljs-string">&quot;Received: %v&quot;</span>, req.Name)<br><span class="hljs-keyword">return</span> &amp;pb.Response&#123;Message: <span class="hljs-string">&quot;Hello &quot;</span> + req.Name&#125;, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在服务端实现上述方法, greeterServer 继承了grpc生成的接口, 这里只需要实现想实现的接口就可以了, 其他方法在调用时会报错未实现  </p><p>这里实现的函数参数和返回值都是固定的, 这个也是为了规范化,如果需要多参数和多返回值, 可以在proto中定义复合类型的message  </p><p>grpc.NewServer() 是 google.golang.org&#x2F;grpc 包提供的一个函数，返回一个 *grpc.Server 类型的对象。<br>它的功能包括：</p><ul><li>监听请求：通过绑定的网络地址（通常使用 net.Listener）接收 gRPC 请求。</li><li>处理注册的服务：调用注册的服务方法来处理具体的 RPC 请求。- 管理生命周期：管理 gRPC 服务的启动、停止、流控等。</li></ul><p> Register<Service>Server 则是将服务实现注册到 gRPC 服务器中, 这里的<code>pb.RegisterGreeterServer(grpcServer, &amp;greeterServer&#123;&#125;)</code>就是将GreeterServer 接口的服务实例（例如 &amp;greeterServer{}）绑定到 gRPC 服务器（grpcServer）。   </p><p> 所有的服务  </p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs proto">service Greeter &#123;<br>    rpc SayHello (HelloRequest) returns (HelloResponse);<br>&#125;<br> ```  <br><br> 在使用 protoc 编译器和 Go 插件后，会生成代码，其中都会包括一个注册函数：<br> `func RegisterGreeterServer(s *grpc.Server, srv GreeterServer)`<br>  <br>这里的注册函数是将服务描述（包括服务名、方法名、方法实现）注入到 gRPC 服务器, 这样就不用手动实现注册(因为服务的具体实现还需要在代码里写, 因此这里需要注册)<br><br>接下来我们来看客户端  <br><br>```go<br>package main<br><br>import (<br>&quot;context&quot;<br>&quot;log&quot;<br>&quot;time&quot;<br><br>pb &quot;path/to/generated/example&quot; // 替换为实际生成代码的包路径<br>&quot;google.golang.org/grpc&quot;<br>)<br><br>func main() &#123;<br>conn, err := grpc.NewClient(&quot;localhost:50051&quot;)<br>if err != nil &#123;<br>log.Fatalf(&quot;Did not connect: %v&quot;, err)<br>&#125;<br>defer conn.Close()<br><br>client := pb.NewGreeterClient(conn)<br><br>ctx, cancel := context.WithTimeout(context.Background(), time.Second)<br>defer cancel()<br><br>response, err := client.SayHello(ctx, &amp;pb.Request&#123;Name: &quot;World&quot;&#125;)<br>if err != nil &#123;<br>log.Fatalf(&quot;Could not greet: %v&quot;, err)<br>&#125;<br>log.Printf(&quot;Response: %s&quot;, response.Message)<br>&#125;<br></code></pre></td></tr></table></figure><p>首先是 grpc建立连接</p><p><code>client := pb.NewGreeterClient(conn)</code><br>这里是建立客户端对象,NewGreeterClient也是protoc自动生成的函数, 用于创建一个服务客户端  </p><p>conn则是一个连接实例  </p><p>而返回的对象就会拥有所有的可用rpc方法了   </p><p>在远程调用时需要用到上下文对象,这里还需要创建一个上下文对象  </p><p><code>ctx, cancel := context.WithTimeout(context.Background(), time.Second)</code>  </p><p>接着就可以远程执行了 </p><p>总结一下  </p><p>对于服务端来说, grpc的过程是  </p><ol><li>创建结构体, 继承Unimplement<servicename>Server<br>|</li><li>实现希望远程调用的函数, 这里的函数签名需要和proto中service的rpc一致<br>|</li><li>使用<code>net.Listen()</code>监听指定端口<br>|</li><li>使用<code>grpc.NewServer</code>创建一个新的server<br>|</li><li>使用protobuffers生成的&#96;Register<Servicename>Server注册服务,将服务和实例绑定在一起 (一个server可以绑定多个service)<br>| </li><li>使用创建的服务中的<code>Serve</code>方法, 接收一个net.Listener, 绑定到监听, 启动服务</li></ol><p>而对于客户端来说, grpc的过程如下  </p><ol><li>使用<code>grpc.NewClient</code>创建一个tcp连接conn, 这里记得defer 关闭这个conn<br>|</li><li>使用New<Servicename>Client创建一个客户端<br>|</li><li>创建一个上下文, 记得defer取消这个上下文<br>|  </li><li>接着,使用这个client中的方法即可远程调用了, client的方法签名和proto中指定的一致</li></ol>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>Go</tag>
      
      <tag>gRPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发：Go项目组织</title>
    <link href="/2024/11/18/%E5%BC%80%E5%8F%91%EF%BC%9AGo%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87/"/>
    <url>/2024/11/18/%E5%BC%80%E5%8F%91%EF%BC%9AGo%E9%A1%B9%E7%9B%AE%E7%BB%84%E7%BB%87/</url>
    
    <content type="html"><![CDATA[<h1 id="项目结构示例"><a href="#项目结构示例" class="headerlink" title="项目结构示例"></a>项目结构示例</h1><p>本人推荐Go Web项目的文件组织方式如下  </p><p>例如，目前有三个服务，auth、notification、api  </p><p>api用于路由配置和 HTTP 请求处理，auth和notification是两个不同功能的服务  </p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">/myapp</span><br>  ├── <span class="hljs-string">/cmd</span>                        <span class="hljs-string">//</span> 启动入口<br>  │   ├── <span class="hljs-string">/api</span>                    <span class="hljs-string">//</span> API 服务的启动入口<br>  │   │   └── main.go             <span class="hljs-string">//</span> 启动应用（API 服务）<br>  │   ├── <span class="hljs-string">/auth</span>                   <span class="hljs-string">//</span> 认证服务的启动入口<br>  │   │   └── main.go             <span class="hljs-string">//</span> 启动应用（认证服务）<br>  │   └── <span class="hljs-string">/notification</span>           <span class="hljs-string">//</span> 通知服务的启动入口<br>  │       └── main.go             <span class="hljs-string">//</span> 启动应用（通知服务）<br>  ├── <span class="hljs-string">/configs</span>                    <span class="hljs-string">//</span> 配置文件<br>  │   └── config.yaml             <span class="hljs-string">//</span> 项目配置文件<br>  ├── <span class="hljs-string">/internal</span>                   <span class="hljs-string">//</span> 内部库，不能被外部引用<br>  │   ├── <span class="hljs-string">/api</span>                    <span class="hljs-string">//</span> API 服务的逻辑模块<br>  │   │   └── router.go     <span class="hljs-string">//</span> 用于处理路由配置<br>  │   ├── <span class="hljs-string">/auth</span>                   <span class="hljs-string">//</span> 认证服务的逻辑模块<br>  │   │   ├── <span class="hljs-string">/handlers</span>           <span class="hljs-string">//</span> 认证请求处理<br>  │   │   ├── <span class="hljs-string">/services</span>           <span class="hljs-string">//</span> 认证业务逻辑<br>  │   │   └── <span class="hljs-string">/repository</span>         <span class="hljs-string">//</span> 认证数据访问<br>  │   └── <span class="hljs-string">/notification</span>           <span class="hljs-string">//</span> 通知服务的逻辑模块<br>  │       ├── <span class="hljs-string">/handlers</span>           <span class="hljs-string">//</span> 通知请求处理<br>  │       ├── <span class="hljs-string">/services</span>           <span class="hljs-string">//</span> 通知业务逻辑<br>  │       └── <span class="hljs-string">/repository</span>         <span class="hljs-string">//</span> 通知数据访问<br>  ├── <span class="hljs-string">/pkg</span>                        <span class="hljs-string">//</span> 公共库，可供多个模块共享<br>  │   ├── <span class="hljs-string">/logger</span>                 <span class="hljs-string">//</span> 自定义日志库<br>  │   ├── <span class="hljs-string">/jwt</span>                    <span class="hljs-string">//</span> JWT 生成与验证库<br>  │   └── <span class="hljs-string">/utils</span>                  <span class="hljs-string">//</span> 工具库，包含常用函数<br>  ├── <span class="hljs-string">/scripts</span>                    <span class="hljs-string">//</span> 自动化脚本<br>  │   └── migrate.go              <span class="hljs-string">//</span> 数据库迁移脚本<br>  ├── <span class="hljs-string">/test</span>                       <span class="hljs-string">//</span> 单元测试和集成测试<br>  │   ├── <span class="hljs-string">/api</span>                    <span class="hljs-string">//</span> API 模块的测试<br>  │   ├── <span class="hljs-string">/auth</span>                   <span class="hljs-string">//</span> 认证模块的测试<br>  │   └── <span class="hljs-string">/notification</span>           <span class="hljs-string">//</span> 通知模块的测试<br>  ├── go.mod                      <span class="hljs-string">//</span> Go 模块文件，包含依赖<br>  ├── go.sum                      <span class="hljs-string">//</span> Go 模块的校验文件<br>  └── README.md                   <span class="hljs-string">//</span> 项目文档<br>```  <br><br><br>其中，handlers是用来从请求中提取参数，并调用services中的函数来完成一层封装的。在handlers中的代码应该尽量简洁轻量，不要有过多的逻辑处理，所有的逻辑应该放在services中实现，repository中是主要负责与数据库的交互，应该将涉及到数据库的代码写在这个模块中<br><br>而api中的router则是配置路由，并将不同的url与不同的handler匹配在一起<br><br>```Go<br>import <span class="hljs-params">(</span><br><span class="hljs-params">    &quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-params">    &quot;myapp/internal/auth/handlers&quot;</span><br><span class="hljs-params">    &quot;myapp/internal/notification/handlers&quot;</span><br><span class="hljs-params">)</span><br>func SetupRouter<span class="hljs-params">()</span> *gin.Engine &#123;<br>    r := gin.Default<span class="hljs-params">()</span><br>    r.GET<span class="hljs-params">(&quot;/auth&quot;, handlers.HandleAuth)</span><br>    r.GET<span class="hljs-params">(&quot;/notification&quot;, handlers.HandleNotification)</span><br>    return r<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多个路由配置文件"><a href="#多个路由配置文件" class="headerlink" title="多个路由配置文件"></a>多个路由配置文件</h2><p>当项目规模更加庞大时，路由的配置会变得相当复杂，所以可能会需要分成多个文件来配置路由，具体实现方式如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Go">/myapp<br>  ├── /cmd                        <span class="hljs-comment">// 启动入口</span><br>  │   ├── /api                    <span class="hljs-comment">// API 服务的启动入口</span><br>  │   │   └── main.<span class="hljs-keyword">go</span>             <span class="hljs-comment">// 启动应用（API 服务）</span><br>  ├── /internal                   <span class="hljs-comment">// 内部库</span><br>  │   └─── /api                    <span class="hljs-comment">// API 服务的业务逻辑</span><br>  │       └── /routes             <span class="hljs-comment">// 路由模块</span><br>  │           ├── auth_routes.<span class="hljs-keyword">go</span>  <span class="hljs-comment">// 认证路由</span><br>  │           ├── user_routes.<span class="hljs-keyword">go</span>  <span class="hljs-comment">// 用户相关路由</span><br>  │           └── product_routes.<span class="hljs-keyword">go</span> <span class="hljs-comment">// 商品相关路由</span><br>  ├── /configs                    <span class="hljs-comment">// 配置文件</span><br>  ├── <span class="hljs-keyword">go</span>.mod                      <span class="hljs-comment">// Go 模块文件</span><br>  └─── README.md                   <span class="hljs-comment">// 项目文档</span><br><br></code></pre></td></tr></table></figure><p>在主路由中，可以采取以下形式  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// cmd/api/main.go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;myapp/internal/api/routes&quot;</span> <span class="hljs-comment">// 导入路由模块</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 初始化 Gin 引擎</span><br>r := gin.Default()<br><br><span class="hljs-comment">// 加载路由模块</span><br>routes.SetupAuthRoutes(r)    <span class="hljs-comment">// 设置认证相关路由</span><br>routes.SetupUserRoutes(r)    <span class="hljs-comment">// 设置用户相关路由</span><br>routes.SetupProductRoutes(r) <span class="hljs-comment">// 设置商品相关路由</span><br><br><span class="hljs-comment">// 启动服务器</span><br>r.Run(<span class="hljs-string">&quot;:8080&quot;</span>) <span class="hljs-comment">// 启动在端口 8080 上</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>而在其他文件中就可具体配置路由了，由于这些函数的参数都是指针，所以在函数中的修改会实际应用到routes上  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// internal/api/routes/auth_routes.go</span><br><span class="hljs-keyword">package</span> routes<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;myapp/internal/api/handlers&quot;</span> <span class="hljs-comment">// 导入处理函数</span><br>)<br><br><span class="hljs-comment">// 设置认证相关的路由</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SetupAuthRoutes</span><span class="hljs-params">(r *gin.Engine)</span></span> &#123;<br>authGroup := r.Group(<span class="hljs-string">&quot;/auth&quot;</span>)<br>&#123;<br>authGroup.POST(<span class="hljs-string">&quot;/login&quot;</span>, handlers.Login)<br>authGroup.POST(<span class="hljs-string">&quot;/logout&quot;</span>, handlers.Logout)<br>authGroup.POST(<span class="hljs-string">&quot;/refresh&quot;</span>, handlers.RefreshToken)<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">// internal/api/routes/user_routes.go</span><br><span class="hljs-keyword">package</span> routes<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;myapp/internal/api/handlers&quot;</span> <span class="hljs-comment">// 导入处理函数</span><br>)<br><br><span class="hljs-comment">// 设置用户相关的路由</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SetupUserRoutes</span><span class="hljs-params">(r *gin.Engine)</span></span> &#123;<br>userGroup := r.Group(<span class="hljs-string">&quot;/users&quot;</span>)<br>&#123;<br>userGroup.GET(<span class="hljs-string">&quot;/&quot;</span>, handlers.GetUsers)<br>userGroup.GET(<span class="hljs-string">&quot;/:id&quot;</span>, handlers.GetUserByID)<br>userGroup.POST(<span class="hljs-string">&quot;/&quot;</span>, handlers.CreateUser)<br>userGroup.PUT(<span class="hljs-string">&quot;/:id&quot;</span>, handlers.UpdateUser)<br>userGroup.DELETE(<span class="hljs-string">&quot;/:id&quot;</span>, handlers.DeleteUser)<br>&#125;<br>&#125;<br><br><br><span class="hljs-comment">// internal/api/routes/product_routes.go</span><br><span class="hljs-keyword">package</span> routes<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="hljs-string">&quot;myapp/internal/api/handlers&quot;</span> <span class="hljs-comment">// 导入处理函数</span><br>)<br><br><span class="hljs-comment">// 设置商品相关的路由</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SetupProductRoutes</span><span class="hljs-params">(r *gin.Engine)</span></span> &#123;<br>productGroup := r.Group(<span class="hljs-string">&quot;/products&quot;</span>)<br>&#123;<br>productGroup.GET(<span class="hljs-string">&quot;/&quot;</span>, handlers.GetProducts)<br>productGroup.GET(<span class="hljs-string">&quot;/:id&quot;</span>, handlers.GetProductByID)<br>productGroup.POST(<span class="hljs-string">&quot;/&quot;</span>, handlers.CreateProduct)<br>productGroup.PUT(<span class="hljs-string">&quot;/:id&quot;</span>, handlers.UpdateProduct)<br>productGroup.DELETE(<span class="hljs-string">&quot;/:id&quot;</span>, handlers.DeleteProduct)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="编译并启动"><a href="#编译并启动" class="headerlink" title="编译并启动"></a>编译并启动</h1><p>编译命令：使用如下命令对不同模块的main文件进行编译  </p><pre><code class="hljs">go build -o myapp-api ./cmd/apigo build -o myapp-auth ./cmd/authgo build -o myapp-notification ./cmd/notification</code></pre><p>所有的main文件实际上都是一个入口程序，只需要编译main文件就可以了，也不用考虑复杂的依赖关系</p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>可以使用Kubernetes对不同的模块进行部署，由于每一个服务都是独立的，因此可以分发到不同docker中，服务间通信使用grpc完成</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>Go</tag>
      
      <tag>项目规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发: Pycharm远程开发与调试</title>
    <link href="/2024/11/04/%E5%BC%80%E5%8F%91-Pycharm%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E4%B8%8E%E8%B0%83%E8%AF%95/"/>
    <url>/2024/11/04/%E5%BC%80%E5%8F%91-Pycharm%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91%E4%B8%8E%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="远程开发原理"><a href="#远程开发原理" class="headerlink" title="远程开发原理"></a>远程开发原理</h1><p>在使用pycharm开发时，需要先准备好远程主机，pycharm的远程开发原理如下：  </p><p>首先需要把文件同步到本地, 然后再对本地的文件进行更改.  </p><p>更改完成后, 可以将做出更改的文件上传到服务器上, 这样就可以完成部署了  </p><p>这么做的原因是JB坚持本地开发-远程部署的原则, 因为JBIDE的类型检查之类的工作必须依靠索引才能完成, 这也就意味着必须要在本地磁盘上才能完成索引  </p><h1 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h1><ol><li><p>配置解释器  </p><p> 如果想要远程开发的话, 最好使用远程解释器, 这样做的好处是能够让多个开发人员使用相同的开发环境(如果不使用docker的话这个方法还是比较好的), 首先要在远程服务器上配置一个虚拟环境, 这里使用虚拟环境创建工具可以创建一个任意版本的python虚拟环境, 后续的开发工作使用这个虚拟环境进行开发即可, 包括项目的运行等等都会使用这个虚拟环境  </p></li><li><p>项目Run&#x2F;Debug Configuration  </p><p> 这个配置项是用于让pycharm知道每次运行代码时需要如何运行代码, 配置项中可以指定运行的脚本, 运行的工作目录, 运行的选项参数等, 但是对于远程开发来说, 只需要将解释器设置为远程解释器即可. 具体如何添加远程解释器的方法这里掠过不讲, 当添加完解释器后, 剩余的的configuration可以当成本地文件来配置  </p></li><li><p>为了方便使用, 在Tools -&gt; Deploymen -&gt; configuration中还需要配置一下Mapping, 也就是目录映射, 将本地的文件和远端的文件对应起来, 找到项目路径即可, 完成配置之后就可以使用部署功能了</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>工具使用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx学习</title>
    <link href="/2024/11/03/Nginx%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/11/03/Nginx%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>有时间我会梳理的, 目前先随便写点吧</p><h1 id="Nginx的网站配置机制"><a href="#Nginx的网站配置机制" class="headerlink" title="Nginx的网站配置机制"></a>Nginx的网站配置机制</h1><p>在nginx的默认安装目录下,&#x2F;etc&#x2F;ngnix中的sites-available中存放着Nginx的配置文件, 这些配置文件是用于存放不同网站的转发规则的, (nginx有负载均衡, 反向代理这些功能, 可以通过配置文件来自定义nginx的行为), 编写好之后, 在sites-enable中创建符号连接<code>ln -s [目标文件] [链接名称] </code> Nginx会根据启用的规则来配置服务器的</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang基础学习</title>
    <link href="/2024/09/30/Golang%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/09/30/Golang%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>这里记录一下我的Golang入门到实战开发过程  </p><h1 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h1><p>Go中的包管理主要分为两个概念，分别是包和模块，包就相当于一个单独的代码文件，模块则可看做是一个文件夹， 文件夹中有很多个包组成  </p><p>而导入一个包的方法如下  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;现在你有了 %g 个问题。\n&quot;</span>，math.Sqrt(<span class="hljs-number">7</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的import语句导入了两个包，分别是fmt和math包，import的方式也可以改为 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;math&quot;</span><br></code></pre></td></tr></table></figure><p>在Go中的变量， 如果一个变量以一个大写字母开头，那么它就是已导出的，例如Pi Student等，这些变量相当于是其它包中导出的变量。这里“导出”的概念为：在使用别的包中的变量时，只能使用导出的变量<br>任何未导出的变量，不能在该包以外的地方访问，这个概念和c++中的extern很像  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Go">math.pi<span class="hljs-comment">//illegal</span><br>math.Pi<span class="hljs-comment">//legal</span><br></code></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Go语言中的函数定义方法如下  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x <span class="hljs-type">int</span>, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> x + y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(add(<span class="hljs-number">42</span>, <span class="hljs-number">13</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>Go中的函数比较反直觉，因为大多数强类型的语言都是类型声明在名称之前，但是Go中却反过来了， 是先写名称，再写类型  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Go">fun add(x <span class="hljs-type">int</span>, y <span class="hljs-type">int</span>) <span class="hljs-type">int</span>&#123;<br>    <span class="hljs-keyword">return</span> x+y<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>为什么要这么写呢，是因为Go注意到了一个历史遗留问题，那就是在C语言中的非常复杂的指针问题 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> (*(*fp)(<span class="hljs-type">int</span> (*)(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>), <span class="hljs-type">int</span>))(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)  <br></code></pre></td></tr></table></figure><p>C语言中会有这种非常复杂的函数指针，当出现这种指针时，我们就很难去分析这个指针到底有什么参数类型。<br>所以Go语言的设计就希望能避免这种问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go">f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>, <span class="hljs-type">int</span>) <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>像这样，先读名称，再读类型，就能很容易的分析出这个函数指针了  </p><p>好了，相信Go语言设计的初衷是为了简化复杂的C++，更有效率的编程，相信谷歌的开发团队！  </p><p>函数的参数还可以简写，当连续两个或者多个已命名的形参类型相同的时候，可以省略重复的类型声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> x + y<br>&#125;<br><span class="hljs-comment">//it is equal to </span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x <span class="hljs-type">int</span>, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> x + y<br>&#125;<br></code></pre></td></tr></table></figure><p>Go语言也可以像python一样返回多个返回值，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> b,a<br>&#125;<br></code></pre></td></tr></table></figure><p>Go的返回值可以被命名</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">split</span><span class="hljs-params">(sum <span class="hljs-type">int</span>)</span></span> (x, y <span class="hljs-type">int</span>) &#123;<br>x = sum * <span class="hljs-number">4</span> / <span class="hljs-number">9</span><br>y = sum - x<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(split(<span class="hljs-number">17</span>))<br>&#125;<br><br><span class="hljs-comment">//output:7 10</span><br></code></pre></td></tr></table></figure><p>这里面的split函数就使用了带名字的返回值，可以看到，如果return语句不加任何返回值的话，会默认返回这些带名字的返回值, 如果一个带名字的返回值在函数声明阶段被命名了，但是在函数内部并没有做任何修改，那么这个返回值就会被赋值为默认值（整形为0 字符串为“”）</p><h2 id="可变长参数"><a href="#可变长参数" class="headerlink" title="可变长参数"></a>可变长参数</h2><p>Go中还可以边长参数，用于处理未知长度的参数的问题，使用变长参数使用如下方法  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printNumbers</span><span class="hljs-params">(numbers ...<span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> _, number := <span class="hljs-keyword">range</span> numbers &#123;<br>        fmt.Println(number)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    printNumbers(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    printNumbers(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以通过在参数类型前加上…来实现边长参数  </p><p>当使用变长参数时, 参数实际上是一个切片, 可以通过访问切片的方式访问变长参数</p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">var</span> x,y <span class="hljs-type">string</span><br>    <span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br>    <span class="hljs-keyword">var</span> b <span class="hljs-type">float64</span><br>    p *<span class="hljs-type">int</span><br>    a [<span class="hljs-number">3</span>]<span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Go语言生命变量用一个var关键字来告诉编译器你声明变量了，然后后面就跟变量名，这里的变量声明的规则最好还是和C++一样，一条变量声明语句里只声明相同类型的变量， 不要写<code>var a int, b float64 </code>这种东西，var 语句可以出现在包或函数的层级。<br>变量初始化时，如果没有指定初始化值，那么变量会被赋值一个默认的值  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> j <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> c, python, java = <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;no!&quot;</span><br>fmt.Println(i, j, c, python, java)<br>&#125;<br><span class="hljs-comment">//output:0  true false no!</span><br></code></pre></td></tr></table></figure><p>变量的声明还可以使用短变量声明，使用短变量声明的时候编译器可以自行推断变量的类型，短变量声明使用短赋值语句，也就是海象运算符 “:&#x3D;”  </p><p>海象运算符不能在函数外使用，因为函数外的每一个语句必须要以关键字开始（var fun等，这么做是为了方便编译）  </p><p>Go语言中的基本类型有：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-type">bool</span><br><span class="hljs-type">string</span><br><span class="hljs-type">int</span>  <span class="hljs-type">int8</span>  <span class="hljs-type">int16</span>  <span class="hljs-type">int32</span>  <span class="hljs-type">int64</span><br><span class="hljs-type">uint</span> <span class="hljs-type">uint8</span> <span class="hljs-type">uint16</span> <span class="hljs-type">uint32</span> <span class="hljs-type">uint64</span> <span class="hljs-type">uintptr</span><br><span class="hljs-type">byte</span> <span class="hljs-comment">// uint8 的别名</span><br><span class="hljs-type">rune</span> <span class="hljs-comment">// int32 的别名</span><br>     <span class="hljs-comment">// 表示一个 Unicode 码位</span><br><span class="hljs-type">float32</span> <span class="hljs-type">float64</span><br><span class="hljs-type">complex64</span> <span class="hljs-type">complex128</span><br></code></pre></td></tr></table></figure><p>Go语言中的类型转换不支持隐式的类型转换，所有的类型转换必须是显式的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> = <span class="hljs-number">42</span><br><span class="hljs-keyword">var</span> f <span class="hljs-type">float64</span> = <span class="hljs-type">float64</span>(i)<br><span class="hljs-keyword">var</span> u <span class="hljs-type">uint</span> = <span class="hljs-type">uint</span>(f)<br><br><span class="hljs-comment">//or</span><br><br>i := <span class="hljs-number">42</span><br>f := <span class="hljs-type">float64</span>(i)<br>u := <span class="hljs-type">uint</span>(f)<br></code></pre></td></tr></table></figure><p>Go语言中存在常量const，const不能用短赋值语句（没有关键字还怎么知道这个是常量呢） </p><p>除此之外，import var const等语句还支持如下写法 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> (<br>    x, y <span class="hljs-type">string</span><br>    a    <span class="hljs-type">int</span><br>    b    <span class="hljs-type">float64</span><br>)<br><span class="hljs-keyword">const</span> (<br><br>    Big = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">100</span><br>    Small = Big &gt;&gt; <span class="hljs-number">99</span><br>)<br><br><span class="hljs-comment">// equal to </span><br><span class="hljs-keyword">var</span> x,y <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">float64</span><br><br><span class="hljs-keyword">const</span> Big = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">100</span><br><span class="hljs-keyword">const</span> Small = Big &gt;&gt; <span class="hljs-number">99</span><br><br></code></pre></td></tr></table></figure><p>可以使用一个括号，括号里面的语句就不需要每一行都单独再写一次关键字了</p><h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>Go语言中的循环只有 for 循环  </p><p>for循环的结构与其它编程语言都相似，初始化，终止条件，后置语句，他们用分号语句隔开，go语言中的for语句没有小括号，但是大括号是必须的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>sum += i<br>&#125;<br>fmt.Println(sum)<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，也可以不要初始化语句和后置语句也可以不要分号</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sum := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> ; sum &lt; <span class="hljs-number">1000</span>; &#123;<span class="hljs-comment">//不带初始化和后置语句的循环</span><br>sum += sum<br>&#125;<br>fmt.Println(sum)  <br><br>    sum := <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> sum &lt; <span class="hljs-number">1000</span> &#123;<span class="hljs-comment">//不带分号的循环， 等同于while，如果需要无限循环的话，就可以不写终止条件</span><br>sum += sum<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h1><p>Go语言中的判断不需要小括号，大括号是必须的 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(x <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> sqrt(-x) + <span class="hljs-string">&quot;i&quot;</span><br>&#125;<br><span class="hljs-keyword">return</span> fmt.Sprint(math.Sqrt(x))<br>&#125;<br><br></code></pre></td></tr></table></figure><p>if可以在条件表达式之前执行一个简短语句，该语句声明的变量作用域在if之内</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pow</span><span class="hljs-params">(x, n, lim <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">if</span> v := math.Pow(x, n); v &lt; lim &#123;<br><span class="hljs-keyword">return</span> v<br>&#125;<br><span class="hljs-keyword">return</span> v<br>&#125;<br></code></pre></td></tr></table></figure><p>这里看到在进行if的条件判断之前执行了一个简短的赋值语句v:&#x3D;math.Pow(x, n)，紧接着一个分号隔开再进行条件表达式  </p><p>Go中还存在switch语句，switch语句也支持一个短赋值语句  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;runtime&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Print(<span class="hljs-string">&quot;Go 运行的系统环境：&quot;</span>)<br><span class="hljs-keyword">switch</span> os := runtime.GOOS; os &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;darwin&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;macOS.&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;linux&quot;</span>:<br>fmt.Println(<span class="hljs-string">&quot;Linux.&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Printf(<span class="hljs-string">&quot;%s.\n&quot;</span>, os)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，Go里面的switch与C语言中的Switch不同，C语言里的switch希望的是能起到Goto的作用，所以每一个case语句后面需要加break才可以结束，否则会顺序依次执行剩下的语句，但是Go语言不会，Go语言会默认在每一个case后面加一个break，除非添加了fallthrough关键字，否则剩余的case语句不会继续执行。  </p><p>switch的执行顺序是从上到下依次匹配剩下的case语句，所以说当存在多个case匹配一个变量时，会优先匹配上面的case  </p><p>Go中的switch不仅能使用常数用于匹配，还可以使用表达式，所以switch语句还存在无条件switch写法，该写法可以将if then else 写的更加清晰</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t := time.Now()<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> t.Hour() &lt; <span class="hljs-number">12</span>:<br>fmt.Println(<span class="hljs-string">&quot;早上好！&quot;</span>)<br><span class="hljs-keyword">case</span> t.Hour() &lt; <span class="hljs-number">17</span>:<br>fmt.Println(<span class="hljs-string">&quot;下午好！&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;晚上好！&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h1><p>defer 语句会将函数推迟到外层函数返回之后执行。</p><p>推迟调用的函数其参数会立即求值，但直到外层函数返回前该函数都不会被调用。</p><p>推迟调用的函数调用会被压入一个栈中。 当外层函数返回时，被推迟的调用会按照后进先出的顺序调用。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;counting&quot;</span>)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">defer</span> fmt.Println(i)<br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;done&quot;</span>)<br><br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">counting</span><br><span class="hljs-comment">done</span><br><span class="hljs-comment">9</span><br><span class="hljs-comment">8</span><br><span class="hljs-comment">7</span><br><span class="hljs-comment">6</span><br><span class="hljs-comment">5</span><br><span class="hljs-comment">4</span><br><span class="hljs-comment">3</span><br><span class="hljs-comment">2</span><br><span class="hljs-comment">1</span><br><span class="hljs-comment">0</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>defer一般用于在函数执行完毕后处理现场，例如关闭文件，释放资源等，使用这种控制流不需要考虑程序执行情况，所有的清理程序都会在程序结束时执行（按照从下到上的顺序）</p><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>Go中的指针声明方式如下  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> p *<span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>在类型前添加*代表声明一个指针变量  </p><p>使用取地址符来获取一变量的地址   </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Go">i:=<span class="hljs-number">2</span><br>p = &amp;i<br></code></pre></td></tr></table></figure><p>使用*可以解引用  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go">*p = <span class="hljs-number">3</span><br>fmt.Println(i)<br><span class="hljs-comment">//output:3</span><br></code></pre></td></tr></table></figure><h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><p>Go中不存在过于复杂的面向对象思想，但是可以使用结构体来完成字段的整合  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>X <span class="hljs-type">int</span><br>Y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>v:=Vertex&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br><br>    fmt.Println(v.X,v.Y)<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用c的时候，我们经常会见到一个结构体指针，为了访问这个结构体指针中的字段一般是使用 <code>-&gt;</code>来获取指针中的字段，但是Go语言允许隐式解应用，即结构体指针也可以使用直接使用<code>.</code>来解引用  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>X <span class="hljs-type">int</span><br>Y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>v := Vertex&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>p := &amp;v<br>p.X = <span class="hljs-number">1e9</span><br>fmt.Println(v)<br>&#125;<br></code></pre></td></tr></table></figure><p>结构体实例化时，可以使用<code>v2 = Vertex&#123;X: 1&#125; </code>这种方式来为结构体赋初始值。 </p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>Go中声明一个数组使用如下方式<br><code>var a [10]int</code>  </p><p>类型 [n]T 表示一个数组，它拥有 n 个类型为 T 的值   </p><p>数组为一个固定大小的元素集合，似乎看上去并没有那么灵活   </p><p>Go中使用切片的概念来让数组变得更加方便好用，语法上与python相似，均为左闭右开  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>primes := [<span class="hljs-number">6</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>&#125;<br><br><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span> = primes[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>]<br>fmt.Println(s)<br>&#125;<br></code></pre></td></tr></table></figure><p>与python不同的是，Go中的切片并不会产生一个新的数组，而是产生对原数据的一个引用，Go的切片更像一个指针，对切片的修改会影响到原来的元素  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>names := [<span class="hljs-number">4</span>]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;John&quot;</span>,<br><span class="hljs-string">&quot;Paul&quot;</span>,<br><span class="hljs-string">&quot;George&quot;</span>,<br><span class="hljs-string">&quot;Ringo&quot;</span>,<br>&#125;<br>fmt.Println(names)<br><br>a := names[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]<br>b := names[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]<br>fmt.Println(a, b)<br><br>b[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;XXX&quot;</span><br>fmt.Println(a, b)<br>fmt.Println(names)<br>&#125;<br><span class="hljs-comment">//output</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">[John Paul George Ringo]</span><br><span class="hljs-comment">[John Paul] [Paul George]</span><br><span class="hljs-comment">[John XXX] [XXX George]</span><br><span class="hljs-comment">[John XXX George Ringo]</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>可以使用<br><code>[]类型&#123;&#125;</code>这种方式创建切片并初始化</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>q := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>&#125;<br>fmt.Println(q)<br><br>r := []<span class="hljs-type">bool</span>&#123;<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>&#125;<br>fmt.Println(r)<br><br>s := []<span class="hljs-keyword">struct</span> &#123;<br>i <span class="hljs-type">int</span><br>b <span class="hljs-type">bool</span><br>&#125;&#123;<br>&#123;<span class="hljs-number">2</span>, <span class="hljs-literal">true</span>&#125;,<br>&#123;<span class="hljs-number">3</span>, <span class="hljs-literal">false</span>&#125;,<br>&#123;<span class="hljs-number">5</span>, <span class="hljs-literal">true</span>&#125;,<br>&#123;<span class="hljs-number">7</span>, <span class="hljs-literal">true</span>&#125;,<br>&#123;<span class="hljs-number">11</span>, <span class="hljs-literal">false</span>&#125;,<br>&#123;<span class="hljs-number">13</span>, <span class="hljs-literal">true</span>&#125;,<br>&#125;<br>fmt.Println(s)<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>如果不指定数组长度，那么编译器会自动计算长度，长度为初始化时填入的元素个数  </p><p>Tips：数组的长度和容量可以使用len()和cap()来获取  </p><p>Go中还存在一个关键字<code>nil</code>这个关键字代表切片的零值，代表一个切片的长度和容量为0，且没有底层数组</p><p>使用make可以创建一个切片（因为不使用make，就需要先拥有一个数组，才能创建切片，或者是使用初始化来创建切片）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br>printSlice(<span class="hljs-string">&quot;a&quot;</span>, a)<br><br>b := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)<br>printSlice(<span class="hljs-string">&quot;b&quot;</span>, b)<br><br>c := b[:<span class="hljs-number">2</span>]<br>printSlice(<span class="hljs-string">&quot;c&quot;</span>, c)<br><br>d := c[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br>printSlice(<span class="hljs-string">&quot;d&quot;</span>, d)<br><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printSlice</span><span class="hljs-params">(s <span class="hljs-type">string</span>, x []<span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s len=%d cap=%d %v\n&quot;</span>,<br>s, <span class="hljs-built_in">len</span>(x), <span class="hljs-built_in">cap</span>(x), x)<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">a len=5 cap=5 [0 0 0 0 0]</span><br><span class="hljs-comment">b len=0 cap=5 []</span><br><span class="hljs-comment">c len=2 cap=5 [0 0]</span><br><span class="hljs-comment">d len=3 cap=3 [0 0 0]</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>meke的三个参数分别是切片类型，长度，容量（可选，如果不指定容量，则默认为长度）</p><p>我们可以将切片用作动态数组，使用append方法来向切片中添加元素  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span><br>s = <span class="hljs-built_in">append</span>(s,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>需要注意的是，这里的append是一个强类型的append，也就是说后面的可变参数的每一个元素必须和第一个参数的类型相同  </p><h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><p>for循环存在一种range形式，使用range可以轻松的遍历切片或者映射  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> pow = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">128</span>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> pow &#123;<br>fmt.Printf(<span class="hljs-string">&quot;2**%d = %d\n&quot;</span>, i, v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用for遍历切片时，每次迭代会有两个值，一个是下标，一个是元素副本  </p><p>如果只需要索引，只需要<br><code>for i:= range pow</code><br>即可  </p><h1 id="map映射"><a href="#map映射" class="headerlink" title="map映射"></a>map映射</h1><p>映射的零值为nil，make函数会返回给定类型的映射  </p><p><code>make(map[KeyType]ValueType, [initialSize])</code>  </p><p>initialSize参数是用于预分配空间的，用于防止频繁的扩容降低代码效率</p><p>声明一个映射的方法为</p><p><code>map VarName [KeyType]ValueType</code> </p><p>映射支持初始化  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br><span class="hljs-string">&quot;Bell Labs&quot;</span>: <span class="hljs-number">12</span>,<br><span class="hljs-string">&quot;Google&quot;</span>: <span class="hljs-number">3</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>添加键值对直接使用<code>m[Key] = Value</code>即可  </p><p>map有一个妙用，当映射的value是一个结构体时，在初始化时会使用如下方法  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>Lat, Long <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Vertex&#123;<br><span class="hljs-string">&quot;Bell Labs&quot;</span>: Vertex&#123;<br><span class="hljs-number">40.68433</span>, <span class="hljs-number">-74.39967</span>,<br>&#125;,<br><span class="hljs-string">&quot;Google&quot;</span>: Vertex&#123;<br><span class="hljs-number">37.42202</span>, <span class="hljs-number">-122.08408</span>,<br>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(m)<br>&#125;<br></code></pre></td></tr></table></figure><p>这里注意到，在写值时，会需要再声明一个Vertex结构体，这样写起来会很麻烦，所以可以直接省略  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>Lat, Long <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-keyword">var</span> m = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]Vertex&#123;<br><span class="hljs-string">&quot;Bell Labs&quot;</span>: &#123;<span class="hljs-number">40.68433</span>, <span class="hljs-number">-74.39967</span>&#125;,<br><span class="hljs-string">&quot;Google&quot;</span>:    &#123;<span class="hljs-number">37.42202</span>, <span class="hljs-number">-122.08408</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(m)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以省略掉值前面的类型  </p><p>如果想删除一个键值对，使用delete函数  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-built_in">delete</span>(m,key)<br></code></pre></td></tr></table></figure><p>可以使用双赋值来检测某个键是否存在，在使用<code>elem = m[key]</code>时，如果键不存在，elem会被赋值为零值而不是报错，所以会比较危险  </p><p>此时，可以使用<code>elem,flag = m[key]</code>如果key不存在，那么flag则会被赋值为false，反之为true</p><p>遍历map，可以用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> m &#123;<br>    fmt.Printf(<span class="hljs-string">&quot;%s: %d\n&quot;</span>, key, value)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不需要value，那么可以省略value，如果不需要key，可以用_代替key。遍历映射时是无序的，如果需要按照特定顺序遍历，可以将键提取到一个切片中，对切片进行排序，然后根据排序的结果访问映射中的值。。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>Go简化了面向对象思想，因此Go中的方法定义会有些独特</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;math&quot;</span><br>)<br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span>&#123;<br>    X,Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span></span> Abs() <span class="hljs-type">float64</span>&#123;<br>    <span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法中，称v Vertex为一个接收者，实际上该种写法与  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Abs</span><span class="hljs-params">(v Vertex)</span></span> <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br></code></pre></td></tr></table></figure><p>并无功能区别，区别在于调用时，方法的调用采取<code>.</code>来调用，而函数则需要传入参数</p><p>当编写了一个带接收者的函数后，就可以使用<code>.</code>来解析使用这个方法了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Go"><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;math&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span>&#123;<br>    X,Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span></span> Abs() <span class="hljs-type">float64</span>&#123;<br>    <span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    v:=Vertex&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br>    fmt.Println(v.Abs())<span class="hljs-comment">//编写了方法,可以使用这种方式调用方法</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>接收者的类型定义和方法声明必须在同一包内。  </p><h2 id="Tips指针接收者与值接收者"><a href="#Tips指针接收者与值接收者" class="headerlink" title="Tips指针接收者与值接收者"></a>Tips指针接收者与值接收者</h2><p>在Go中的方法可以根据特征区分为使用指针接收者的方法和使用值接收者的方法  </p><p>指针类型接收者的方法声明为  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Vertex)</span></span> Scale(f <span class="hljs-type">float64</span>) &#123;<br>v.X = v.X * f<br>v.Y = v.Y * f<br>&#125;<br></code></pre></td></tr></table></figure><p>值类型接收者的方法声明为  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br></code></pre></td></tr></table></figure><p>区别在于类型T前加了指针运算符<code>*</code>, 区别体现在, 如果使用指针接收者, 那么对于一个实例化后的对象, 使用指针接收者的方法会对该对象的成员做出实质性的修改, 而使用值接收者只会对该对象的副本进行更改  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>X, Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Vertex)</span></span> Scale(f <span class="hljs-type">float64</span>) &#123;<br>v.X = v.X * f<br>v.Y = v.Y * f<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>v := Vertex&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>v.Scale(<span class="hljs-number">10</span>)<span class="hljs-comment">//该方法是使用指针接收者, </span><br>fmt.Println(v.Abs())<br>&#125;<br><br></code></pre></td></tr></table></figure><p>接收者中的名称就相当于this的别称，可以自己取名字的this，一个方法只能有一个接受者  </p><h2 id="Tips方法与指针重定向"><a href="#Tips方法与指针重定向" class="headerlink" title="Tips方法与指针重定向"></a>Tips方法与指针重定向</h2><p>指针实例和值实例都可以调用方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Vertex)</span></span> Scale(f <span class="hljs-type">float64</span>) &#123;<br>v.X = v.X * f<br>v.Y = v.Y * f<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> v Vertex<br>v.Scale(<span class="hljs-number">5</span>)  <span class="hljs-comment">// OK</span><br>p := &amp;v<br>p.Scale(<span class="hljs-number">10</span>) <span class="hljs-comment">// OK</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>Go 会将语句 v.Scale(5) 解释为 (&amp;v).Scale(5)  </p><p>反过来也可以，值和指针都可以调用值接收者方法</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口的概念等同于一组方法的签名  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Phone <span class="hljs-keyword">interface</span> &#123;<br>    call()<br>&#125;<br><br><span class="hljs-keyword">type</span> NokiaPhone <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(nokiaPhone NokiaPhone)</span></span> call() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;I am Nokia, I can call you!&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> IPhone <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(iPhone IPhone)</span></span> call() &#123;<br>    fmt.Println(<span class="hljs-string">&quot;I am iPhone, I can call you!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> phone Phone<br><br>    phone = <span class="hljs-built_in">new</span>(NokiaPhone)<br>    phone.call()<br><br>    phone = <span class="hljs-built_in">new</span>(IPhone)<br>    phone.call()<br><br>&#125;<br><span class="hljs-comment">//这里的new是第一次出现，该函数的作用是分配内存并返回指向该类型的指针，并将该内存区域的内容初始化为该类型的零值</span><br><br><span class="hljs-comment">//与make不同的是，make主要用于初始化slice，map和channel</span><br><br><span class="hljs-comment">//new的使用场景为需要明确获得指针的时候才需要使用，其它情况不需要，其它情况使用声明也是可以的</span><br></code></pre></td></tr></table></figure><p>这里再举一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Abser <span class="hljs-keyword">interface</span> &#123;<br>Abs() <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a Abser<br>f := MyFloat(-math.Sqrt2)<br>v := Vertex&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><br>a = f  <span class="hljs-comment">// a MyFloat 实现了 Abser</span><br>a = &amp;v <span class="hljs-comment">// a *Vertex 实现了 Abser</span><br><br><span class="hljs-comment">// 下面一行，v 是一个 Vertex（而不是 *Vertex）</span><br><span class="hljs-comment">// 所以没有实现 Abser。</span><br>a = v<br><br>fmt.Println(a.Abs())<br>&#125;<br><br><span class="hljs-keyword">type</span> MyFloat <span class="hljs-type">float64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f MyFloat)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">if</span> f &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(-f)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(f)<br>&#125;<br><br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>X, Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Vertex)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里的代码运行会出问题，原因是出在<code>a = v</code>这一行上了 ，编译器会报错，<code>cannot use v (variable of type Vertex) as Abser value in assignment: Vertex does not implement Abser (method Abs has pointer receiver)</code>  </p><p>这是因为Abs 方法只为 *Vertex （指针类型）定义，因此 Vertex（值类型）并未实现 Abser。  </p><p>但是这里有一些特别奇怪的点，那就是如果在定义方法时直接使用值接收者来定义方法，那么无论是使用指针还是值赋值给接口都是可以成功编译的。接下来外我们来调查这个问题</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Abser <span class="hljs-keyword">interface</span> &#123;<br>Abs() <span class="hljs-type">float64</span><br>&#125;<br><span class="hljs-keyword">type</span> Vertex <span class="hljs-keyword">struct</span> &#123;<br>X, Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a Abser<br>v := Vertex&#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br>a = &amp;v <span class="hljs-comment">// 明明这里没有实现*Vertex的方法，但是仍然能赋值给接口，这是为啥呢？</span><br>fmt.Println(a.Abs())<br>a = v   <br>fmt.Println(a.Abs())<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h2 id="Tips接口和指针"><a href="#Tips接口和指针" class="headerlink" title="Tips接口和指针"></a>Tips接口和指针</h2><p>值接收器的方法隐式地同时被声明为指针类型的方法。反之一样   </p><p>拿Vertex举例，当定义方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Vertex)</span></span> Abs() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Sqrt(v.X*v.X + v.Y*v.Y)<br>&#125;<br></code></pre></td></tr></table></figure><p>则Vertex和*Vertex的方法集中都会存在这个名为Abs的方法  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">var</span> v = Vertex&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;<br>v.Abs()<br>(&amp;v).Abs()<br><span class="hljs-comment">//两种调用都OK</span><br></code></pre></td></tr></table></figure><p>反之，如果只定义*Vertex的Abs方法，Vertex和*Vertex的方法集中也都会有Abs这个方法，这就是为什么Go官方文档不建议一个类型中，值接收者和指针接收者混用  </p><p>那么现在来看接口这个概念，当定义了一个接口后，如果想用一个类型实现这个接口，那么编译器会检查这个类型中是否完成了接口中的方法集，如果没有完成，那么编译器会报错  </p><p>Go语言编译器在检查一个接口是否被完成的时候，会遵循以下规则   </p><p><strong>值接收器</strong>：如果类型中的方法是值接收器，那么值类型和指针类型都可以实现该接口。  </p><p><strong>指针接收器</strong>：如果类型中的方法有指针接收器，那么只有指针类型可以实现该接口，值类型不能直接实现。</p><p>(<em>这里的实现通俗点理解可以理解为赋值</em>)</p><p> 出现这个现象的原因是，接口存储的是一个指针或者一个值，当接口存储了一个值时，接口希望调用自身的一个指针接受器方法，接口会发现无法调用，这是因为接口存储的是值而不是指针。接口存储了值，就说明接口无法寻找到这个值原本是存在哪里的，自然也就无法调用指针接收器方法了。  </p><p> 所以说，要理解接口实际上也是一个变量这个概念  </p><h2 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h2><p>Go中存在一个概念交空接口，空接口的定义方式为：  </p><p><code>var i interface&#123;&#125;</code>  </p><p>空接口可以接受任意类型的值，一般这种空接口用于处理未知类型的值。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125;<br>describe(i)<br><br>i = <span class="hljs-number">42</span><br>describe(i)<br><br>i = <span class="hljs-string">&quot;hello&quot;</span><br>describe(i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">describe</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;(%v, %T)\n&quot;</span>, i, i)<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，空接口通常被当作一个类型，而不是一个值</p><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p><code>value, ok := x.(T)</code>  </p><p>类型断言用于从接口类型变量中提取具体值的机制，因为接口在底层中存储了两个东西，分别是值和类型，那么就可以用类型断言来获取接口的类型  </p><ul><li><p>断言成功： 当接口 x 实际上保存的是类型 T 的值时，断言会成功，value 会持有该具体类型的值，ok 会是 true。</p></li><li><p>断言失败： 如果接口 x 中保存的值并不是类型 T，那么断言会失败，此时 value 为类型 T 的零值，ok 为 false。</p></li></ul><p>当然也可以不用ok变量，如果不用ok变量直接使用类型断言会引发一个panic  </p><p>除此之外，还有一种静态检查的方式</p><p><code>var _ TargetInterface = (*MyStruct)(nil)</code>  </p><p>其中，nil是一个空指针，省略变量名，而（*MyStruct）则将这个指针强制类型转换为了MyStruct类型，而TargetInterface则是一个要检查的接口，如果这个接口没有实现，则在编译期就会报错，省去了在运行时出错处理错误的时间</p><h2 id="类型选择"><a href="#类型选择" class="headerlink" title="类型选择"></a>类型选择</h2><p>Go中的类型断言还可以用于switch语句，使用类型选择断言时，可以对一个接口类型的变量进行<code>i.(type)</code>操作  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkType</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    <span class="hljs-keyword">switch</span> v := i.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:<br>        fmt.Println(<span class="hljs-string">&quot;整型:&quot;</span>, v)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>        fmt.Println(<span class="hljs-string">&quot;字符串:&quot;</span>, v)<br>    <span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>:<br>        fmt.Println(<span class="hljs-string">&quot;布尔型:&quot;</span>, v)<br>    <span class="hljs-keyword">default</span>:<br>        fmt.Println(<span class="hljs-string">&quot;未知类型&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    checkType(<span class="hljs-number">10</span>)<br>    checkType(<span class="hljs-string">&quot;hello&quot;</span>)<br>    checkType(<span class="hljs-literal">true</span>)<br>    checkType(<span class="hljs-number">3.14</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Stringer重构"><a href="#Stringer重构" class="headerlink" title="Stringer重构"></a>Stringer重构</h2><p>接口的fmt包中有一个Stringer接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;<br>    String() <span class="hljs-type">string</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>实现这个接口，可以自定义println时输出数据的格式  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">func (p Person) String() string &#123;</span><br><span class="hljs-comment">return fmt.Sprintf(&quot;%v (%v years)&quot;, p.Name, p.Age)</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := Person&#123;<span class="hljs-string">&quot;Arthur Dent&quot;</span>, <span class="hljs-number">42</span>&#125;<br>z := Person&#123;<span class="hljs-string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="hljs-number">9001</span>&#125;<br>fmt.Println(a, z)<br>&#125;<br><span class="hljs-comment">//&#123;Arthur Dent 42&#125; &#123;Zaphod Beeblebrox 9001&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%v (%v years)&quot;</span>, p.Name, p.Age)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := Person&#123;<span class="hljs-string">&quot;Arthur Dent&quot;</span>, <span class="hljs-number">42</span>&#125;<br>z := Person&#123;<span class="hljs-string">&quot;Zaphod Beeblebrox&quot;</span>, <span class="hljs-number">9001</span>&#125;<br>fmt.Println(a, z)<br>&#125;<br><span class="hljs-comment">//Arthur Dent (42 years) Zaphod Beeblebrox (9001 years)</span><br></code></pre></td></tr></table></figure><p>可以看到，可以通过这种实现接口的方式来达到重构的效果，当println收到Person类型的参数时，就会使用自定义的String（）类型的方法来输出字符串了  </p><h1 id="Go协程"><a href="#Go协程" class="headerlink" title="Go协程"></a>Go协程</h1><p>协程可以让Go轻易的进行并发操作  </p><p><code>Go f([var])</code>  </p><p>其中，函数参数的求值会在当前的Go协程中完成，函数f的执行会在新的Go协程中完成  </p><h1 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h1><p>信道是带有类型的管道，你可以通过它用信道操作符 &lt;- 来发送或者接收值。</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">ch &lt;- v    <span class="hljs-comment">// 将 v 发送至信道 ch。</span><br>v := &lt;-ch  <span class="hljs-comment">// 从 ch 接收值并赋予 v。</span><br></code></pre></td></tr></table></figure><p>（“箭头”就是数据流的方向。）</p><p>和映射与切片一样，信道在使用前必须创建：</p><p><code>ch := make(chan int)</code>  </p><p>默认情况下，发送和接收操作在另一端准备好之前都会阻塞。这使得 Go 程可以在没有显式的锁或竞态变量的情况下进行同步。</p><p>例如上面的例子，<br>&lt;-ch 会等待直到信道中有值可供接收。如果信道中还chan没有值，goroutine 会阻塞，直到有值发送到信道为止。 </p><p>来看一个具体的代码  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(s []<span class="hljs-type">int</span>, c <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>sum := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s &#123;<br>sum += v<br>&#125;<br>c &lt;- sum <span class="hljs-comment">// 发送 sum 到 c</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">7</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">-9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>&#125;<br><br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> sum(s[:<span class="hljs-built_in">len</span>(s)/<span class="hljs-number">2</span>], c)<br><span class="hljs-keyword">go</span> sum(s[<span class="hljs-built_in">len</span>(s)/<span class="hljs-number">2</span>:], c)<br>x, y := &lt;-c, &lt;-c <span class="hljs-comment">// 从 c 接收</span><br><br>fmt.Println(x, y, x+y)<br>&#125;<br></code></pre></td></tr></table></figure><p>对于这段代码，具体的执行过程如下  </p><ul><li><p>启动两个 goroutine 并开始并发计算： 代码中 go sum(…) 启动了两个 goroutine，它们会并发地计算 s 切片的前后部分的和。这两个 goroutine 会执行 sum 函数，并在计算完毕后尝试向信道 c 发送结果。</p></li><li><p>第一个 goroutine 的发送操作阻塞： 假设 sum(s[:len(s)&#x2F;2], c) 计算完后，尝试向信道 c 发送结果。因为信道是无缓冲的，发送操作会阻塞，直到主函数开始接收数据。</p></li><li><p>第二个 goroutine 的发送操作阻塞： 同时，sum(s[len(s)&#x2F;2:], c) 也会尝试向信道 c 发送结果，并且它同样会阻塞，等待接收者接收数据。</p></li><li><p>主函数的接收操作： 主函数执行到 x, y :&#x3D; &lt;-c, &lt;-c 时，开始从信道 c 接收数据。第一个 &lt;-c 会解除一个阻塞的发送操作，使其中一个 goroutine 将结果发送过来并继续执行。然后，主函数继续执行第二个 &lt;-c，解除另一个 goroutine 的阻塞，并接收第二个结果。</p></li><li><p>接收完毕，所有阻塞解除： 当两个 &lt;-c 都执行完毕时，主函数和两个 goroutine 都不再阻塞，程序的计算部分已经完成，主函数最终打印结果。</p></li></ul><h2 id="带缓冲的信道"><a href="#带缓冲的信道" class="headerlink" title="带缓冲的信道"></a>带缓冲的信道</h2><p>信道可以是带缓冲的，将长度做为第二个参数提供给make用于创建一个带缓冲的信道  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Go"> <span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>ch &lt;- <span class="hljs-number">1</span><br>ch &lt;- <span class="hljs-number">2</span><br>fmt.Println(&lt;-ch)<br>fmt.Println(&lt;-ch)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>仅当信道的缓冲区填满后，向其发送数据时才会阻塞。当缓冲区为空时，接受方会阻塞。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">2</span>)<br>fmt.Println(&lt;-ch)<span class="hljs-comment">//错误,死锁,接收方一直处于阻塞</span><br><br>ch &lt;- <span class="hljs-number">1</span><br>ch &lt;- <span class="hljs-number">2</span><br><span class="hljs-comment">//v := &lt;-ch</span><br>ch &lt;- <span class="hljs-number">3</span> <span class="hljs-comment">//错误,死锁, 发送方一直处于阻塞</span><br><br>fmt.Println(&lt;-ch)<br>fmt.Println(&lt;-ch)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="close语句"><a href="#close语句" class="headerlink" title="close语句"></a>close语句</h2><p>关闭信道使用close方法  </p><p><code>close(c)</code>  </p><p>如果需要判断一个信道是否被关闭,使用双值检测  </p><p>v,ok :&#x3D; &lt;-ch  </p><p>如果已经被关闭,那么ok会被赋值为false  </p><p>这里需要注意的是, 信道只有在其中的值被取完了， 才会ok &#x3D;&#x3D; false， 并且从已经关闭的管道里取东西会取到0值</p><p>向关闭的通道发送数据也会导致panic</p><h2 id="range语句"><a href="#range语句" class="headerlink" title="range语句"></a>range语句</h2><p>如果使用range语句  </p><p><code>for i := range c</code>  </p><p>那么循环会不断从信道接收值,直到其被关闭。  </p><h2 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h2><p>select 语句使一个 Go 程可以等待多个通信操作。</p><p>  select 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fibonacci</span><span class="hljs-params">(c, quit <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>x, y := <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> c &lt;- x:<br>x, y = y, x+y<br><span class="hljs-keyword">case</span> &lt;-quit:<br>fmt.Println(<span class="hljs-string">&quot;quit&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>quit := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>fmt.Println(&lt;-c)<br>&#125;<br>quit &lt;- <span class="hljs-number">0</span><br>&#125;()<br>fibonacci(c, quit)<br>&#125;<br></code></pre></td></tr></table></figure><p>来看这个例子，使用select go并发，信道实现的斐波那契  </p><ul><li><p>首先，go开启一个协程func，协程中打印1到10的斐波那契数列，打印完成之后给quit这个信道发送一个信号0  </p></li><li><p>开启协程后，程序继续向下执行，直到遇到fibonacci函数，开始执行fibonacci函数 </p></li><li><p>fibonacci函数中会选择分支，当一个信道没有处于阻塞态时，select就会执行对应的分支。case<code>c&lt;-x</code>语句会把值x传递给c，当c的值被取出前该语句堵塞。case <code>&lt;-quit</code>语句会发生堵塞，等待quit接受新的值。  </p></li><li><p>在新开启的go程中，println需要接受值，所以会堵塞，直到执行Fibonacci函数的go程中给c传入值才会执行println </p></li><li><p>当循环结束后，像quit传入值，<code>&lt;-quit</code>不再堵塞。，switch执行 <code>&lt;-quit</code> Fibonacci函数结束</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Go"><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>tick := time.Tick(<span class="hljs-number">100</span> * time.Millisecond)<br>boom := time.After(<span class="hljs-number">500</span> * time.Millisecond)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-tick:<br>fmt.Println(<span class="hljs-string">&quot;tick.&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-boom:<br>fmt.Println(<span class="hljs-string">&quot;BOOM!&quot;</span>)<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;    .&quot;</span>)<br>time.Sleep(<span class="hljs-number">50</span> * time.Millisecond)<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当 select 中的其它分支都没有准备好时，default 分支就会执行。</p><p>为了在尝试发送或者接收时不发生阻塞，可使用 default 分支：  </p><h2 id="单向信道"><a href="#单向信道" class="headerlink" title="单向信道"></a>单向信道</h2><p>chan&lt;- int 是一个只能发送的通道，可以发送但是不能接收；<br>&lt;-chan int 是一个只能接收的通道，可以接收但是不能发送。  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">squarer</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>, in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> in &#123;<br>        out &lt;- i * i<br>    &#125;<br>    <span class="hljs-built_in">close</span>(out)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printer</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> in &#123;<br>        fmt.Println(i)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里可以看到, 参数中指定了信道的类型为单向信道   </p><p>有的时候我们会将通道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用通道都会对其进行限制，比如限制通道在函数中只能发送或只能接收。</p><h1 id="代码组织"><a href="#代码组织" class="headerlink" title="代码组织"></a>代码组织</h1><p>在Go中有非常方便的代码组织方式  </p><p>以下列文件结构为例  </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima">myproject/<br>│<br>├── <span class="hljs-built_in">go</span>.<span class="hljs-built_in">mod</span><br>├── main.<span class="hljs-built_in">go</span><br>└── config/<br>    └── config.<span class="hljs-built_in">go</span><br><br></code></pre></td></tr></table></figure><p>在main.go中就可以以如下方式使用自己编写的包  </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-comment">// main.go</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;myproject/config&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 访问导出的变量 MaxConnections</span><br>    fmt.Println(<span class="hljs-string">&quot;MaxConnections:&quot;</span>, config.MaxConnections)<br><br>    <span class="hljs-comment">// 可以修改导出的变量</span><br>    config.MaxConnections = <span class="hljs-number">200</span><br>    fmt.Println(<span class="hljs-string">&quot;Updated MaxConnections:&quot;</span>, config.MaxConnections)<br><br>    <span class="hljs-comment">// 不能访问未导出的变量 minConnections</span><br>    <span class="hljs-comment">// fmt.Println(&quot;MinConnections:&quot;, config.minConnections)  // 错误，无法访问</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>变量名，类型名，函数名的开头如果是一个大写字母，那么就说明这个是一个可以导出的变量。你可以在其它任何包中导入这些内容  </p><p>但是如果这些内容的变量名是一个小写字母开头，那么就只能在该包的内部使用这些内容  </p><p>一个包的最开头的package中必须声明这个包是属于哪个模块的，我们一般情况下package后面声明的模块与包所处文件夹同名</p><p>一个模块使用一个文件夹组织所有的包，一个模块可以有多个包</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>编程</tag>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cmake示例</title>
    <link href="/2024/09/26/Cmake%E7%A4%BA%E4%BE%8B/"/>
    <url>/2024/09/26/Cmake%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>这里给出一个基本的Cmake的例子</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs text"># 设置最低CMake版本<br>cmake_minimum_required(VERSION 3.10)<br><br># 设置项目名称和版本号<br>project(MyProject VERSION 1.0)<br><br># 设置C++标准<br>set(CMAKE_CXX_STANDARD 11)<br>set(CMAKE_CXX_STANDARD_REQUIRED True)<br><br># 指定源文件<br>set(SOURCES<br>    src/main.cpp<br>    src/helper.cpp<br>)<br><br># 添加可执行文件<br>add_executable(MyExecutable $&#123;SOURCES&#125;)<br><br># 添加包含目录<br>target_include_directories(MyExecutable PUBLIC include)<br><br># 添加链接库（如果有依赖）<br># target_link_libraries(MyExecutable PRIVATE some_library)<br><br># 可选：设置安装目标<br>install(TARGETS MyExecutable DESTINATION bin)<br><br># 可选：设置单元测试（需要开启 CMake Testing 模块）<br>enable_testing()<br><br>add_executable(testRunner tests/test_main.cpp)<br>target_link_libraries(testRunner PRIVATE MyExecutable)<br><br>add_test(NAME MyTest COMMAND testRunner)<br><br></code></pre></td></tr></table></figure><p>其中target_include_directories(MyExecutable PUBLIC include) 意思为在编译MyExecutable这个可执行文件时, 需要去include这个文件夹下寻找头文件, 其中第二个参数的可选项如下</p><p>PUBLIC：如果头文件不仅仅是这个目标（如 MyProgram）需要用到，其他目标（如库或者其他可执行文件）也需要包含这些头文件时，使用 PUBLIC。<br>PRIVATE：仅在这个目标内使用头文件，其他目标不需要包含这个目录。<br>INTERFACE：只有在其他目标链接到这个目标时才需要包含头文件，而当前目标不需要。</p>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue学习</title>
    <link href="/2024/07/09/Vue%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/07/09/Vue%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="文本插值"><a href="#文本插值" class="headerlink" title="文本插值"></a>文本插值</h2><p>文本插值使用&#123;&#123; &#125;&#125;, 在template中可以任意使用文本插值, 文本插值支持表达式(必须是合法的表达式,不支持条件控制,但是支持三目运算符<br>)  </p><p>如果希望文本插值的字符串以html的方式渲染, 需要使用v-html标签(这里也被叫做指令) </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>  export default&#123;<br>    data()&#123;<br>      return&#123;<br>        msg:&quot;hello world&quot;,<br>      rawHTML:&quot;&lt;a herf = #&gt;&lt;/a&gt;&quot;<br>      &#125;<br>    &#125;<br>  &#125;<br>&lt;template&gt;<br>&lt;p v-html= &quot;rawHTML&quot;&gt;&lt;/p&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><h2 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h2><p>文本插值不能用于属性, 也就是说</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class = &quot;&#123;&#123;msg&#125;&#125;&quot;&gt;test&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    data()&#123;<br>        return&#123;<br>            msg:&quot;active&quot;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>上面这个写法是不行的, 必须使用属性绑定才能解决这个问题</p><p>属性绑定写法如下(使用v-bind指令)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div v-bind:class = &quot;msg&quot;&gt;test&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    data()&#123;<br>        return&#123;<br>            msg:&quot;active&quot;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>这里的v-bind可以忽略, 直接写成<code>&lt;div :class = &quot;msg&quot;&gt;test&lt;/div&gt;</code></p><p>同时, 属性绑定支持对象绑定  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div v-bind:class = &quot;msg&quot;&gt;test&lt;/div&gt;<br>&lt;div v-bind = &quot;obj&quot;&gt; &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script&gt;<br>export default&#123;<br>    data()&#123;<br>        return&#123;<br>            msg:&quot;active&quot;<br>                obj:&#123;<br>                d1:&quot;dclass&quot;,<br>                    d2:&quot;did&quot;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>上面的代码中, 第二个div进行了对象绑定, 在html中会发现多了两个自定义属性, 分别是d1&#x3D;”dclass”, d2&#x3D;”did”, 如果想让其变成id和class, 修改obj中的key就可以了</p><h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>条件渲染的指令有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">v-if<br>v-else<br>v-else-if<br>v-show<br></code></pre></td></tr></table></figure><p>使用方法为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div v-if = &quot;flag&quot;&gt;hello&lt;/div&gt;<br>&lt;div v-else&gt;goodbye&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>这里如果flag为真,那么就渲染hello, 否则渲染goodbye, 前提是flag得是data中的数据</p><h3 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h3><p>列表渲染的指令如下 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vue">v-for<br></code></pre></td></tr></table></figure><p>使用方法为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vues">&lt;script&gt;<br>export default&#123;<br>data()&#123;<br>    return&#123;<br>        names :[1,2,3,4,5]<br>        &#125;<br>    &#125;<br><br><br>&#125;<br>&lt;/script&gt;<br>&lt;template&gt;<br> &lt;div v-for = &quot;item in names&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>上面的代码会渲染出五个div,分别是names中的所有元素</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python: 装饰器</title>
    <link href="/2024/05/28/Python-%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <url>/2024/05/28/Python-%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>Python装饰器起到一个在函数前加点东西的作用  </p><p><img src="/images/pasted-83.png" alt="upload successful">  </p><p>这是最开始的函数, 然后我现在希望实现下面这个业务模式  </p><ul><li>当执行一个函数时, 我希望它先打印”666”, 然后再继续执行后面的函数</li></ul><p>这里的实现过程就很有意思了, 如果只有一个func1还好说, 但是假如有func2呢, 有func3呢, 有func100呢? 总不能把这些函数全部重新写一遍 ,这样就很浪费时间, 并且搞不好还会出错, 所以就需要一个类似装饰器的东西来解决这个问题  </p><p>从上层到下层来看,装饰器就是这样的:</p><p><img src="/images/pasted-84.png" alt="装饰器执行流程图">  </p><p>那么现在可以来看装饰器的原理了  </p><p><img src="/images/pasted-85.png" alt="装饰器原理">  </p><p>上图代码就是一个实现装饰器的过程, 装饰器函数接收一个函数, 然后新合成一个函数, 这个新合成的函数就是先执行打印666, 然后再把函数控制权转交出去, 这里第10行的部分其实就是获取这个新合成的函数的过程  </p><p>当然这么写肯定太捞了, 所以要换一种写法  </p><p><img src="/images/pasted-86.png" alt="python风格的写法">   </p><p>这里使用@加函数名即可, 其本质和上面的语句没有区别, 就是<code>func = zhuangshiqi(func)</code>, 这里使用@装饰器写法时, 会默认把@zhuangshiqi后面跟着的函数作为参数传递给zhuangshiqi这个函数, 所以如果定义装饰器函数的时候不给它指定参数会报错  </p><p><img src="/images/pasted-87.png" alt="upload successful">  </p><p>当然, 装饰器比较灵活, 这里还有带参数的装饰器可以用<br><img src="/images/pasted-88.png" alt="带参数的装饰器"><br>这里的原理其实是, 先把老八这个参数传递给decorator中的laotie, 然后这个decorator函数返回了一个zhuangshiqi函数, 这个装饰器函数又需要接收一个func参数, 然后来返回一个合成过的函数出来, 也就是说这里func拿到的其实是包装了两层后的func, 可能比较绕, 反正用的时候多试试就好了</p><p><img src="/images/pasted-89.png" alt="老八吃粑粑">  </p><p>像这样传递多个参数也是可以的</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows下的保护模式</title>
    <link href="/2024/05/26/Windows%E4%B8%8B%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/05/26/Windows%E4%B8%8B%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>任务就是指线程或者进程, 我们可以把保护机制划分为任务间的保护和任务内的保护</p><h2 id="任务间的保护"><a href="#任务间的保护" class="headerlink" title="任务间的保护"></a>任务间的保护</h2><p>在Win32版本下, 每个任务都被赋予4GB的虚拟内存空间,  可用地址为0~0XFFFFFFFF, 这里的意思就是说在这个虚拟的内存空间中可以存放任务的代码和数据等信息, 当这个任务实际被使用时, 看物理地址哪有空往哪放, 这也是虚拟的含义。  </p><p>当有了虚拟地址后，就会发现我们无法更改另一个程序的内存，只能更改本程序内存空间内的地址（也就是4GB的空间，0~0XFFFFFFFF）这样就防止在程序内修改其它程序的数据了</p><h2 id="任务内的保护"><a href="#任务内的保护" class="headerlink" title="任务内的保护"></a>任务内的保护</h2><p>任务内的保护是指，windows操作系统的代码和数据通常被映射到每个进程的高2GB的空间中，这就意味着操作系统的空间是可以被程序修改的，所以需要任务内的保护。为了保护操作系统的代码，程序通常被赋予特权值，地特权的代码不能访问和执行高特权的代码，这就防止了用户自己编写的代码访问操作系统的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">*(<span class="hljs-type">int</span>*) <span class="hljs-number">0xA0808080</span>=<span class="hljs-number">0x22</span>;<br></code></pre></td></tr></table></figure><p>像上述语句就会触发系统的检测机制,从而产生报错</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows下的分页机制</title>
    <link href="/2024/05/19/%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/05/19/%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>本节参考《软件调试》卷一 2.7节  </p><p>操作系统在创建进程时， 就会为这个进程创建页表，页表是进程空间的物理基础</p><h2 id="32位经典分页"><a href="#32位经典分页" class="headerlink" title="32位经典分页"></a>32位经典分页</h2><p>  此处的经典是指没有开启PAE的分页模式，在该模式下，页表结构分为两级，第一级称为页目录表（Page Driectory），第二级称为页表（Page Table）。<br>  PD是一个存放页目录表项（Page Directory Entry） 的线性表，<em>每个PD占4KB</em>的内存， <em>每个PDE占32bit</em>， 所以一个PD最多可以有1024个PDE。</p><p><img src="/images/pasted-72.png" alt="页表与页目录表的关系"></p><p> PDE可以用于指向下一个PD，格式如下   </p><p><img src="/images/pasted-68.png" alt="指向PT的PDE的格式">  </p><p>当然也可以用于指向一个4MB的大内存页  </p><p><img src="/images/pasted-69.png" alt="指向4MB内存页的PDE的格式">  </p><p>而页表(Page Table)是用来存放页表表项(Page Table Entry)的线性表, 每个PT占4KB, 每个PTE占32bit, PTE的具体格式如下  </p><p><img src="/images/pasted-71.png" alt="PTE格式">  </p><p>现在来看CPU是如何将一个32bit的线性地址翻译为32bit的物理地址的  </p><ol><li><p>通过CR3寄存器定位到PD的起始地址,取该线性地址的高10bit作为索引选取PDE  </p></li><li><p>判断PDE的 PS位, 如果为1, 代表这个PDE指向一个4MB的大内存页, PDE的高10bit便是4MB内存页的基地址的高10位, 该线性地址的低22bit便是页内偏移, 将二者结合到一起就是物理地址了。如果PS为0，那么根据PDE中高20位定位到PT  </p></li><li><p>取该线性地址的12bit到21bit作为索引选取PT的一个表项，也就是PTE。  </p></li><li><p>取出PTE的高20位</p></li><li><p>取该线性地址的低12bit作为页内偏移与上一步的地址相加便能得到物理地址</p></li></ol><p>现在以软件调试中给出的实验材料进行实验  sdbgvola\dumps\xpsp3nop  </p><p><img src="/images/pasted-73.png" alt="upload successful">  </p><p>以这里的f8c2e04d为例, 该地址为线性地址  </p><p><img src="/images/pasted-74.png" alt="upload successful">  </p><p>转化为二进制后长这样  </p><p><img src="/images/pasted-75.png" alt="upload successful">  </p><p>然后把高十位的值计算出来, 为PDE的索引  </p><p><img src="/images/pasted-76.png" alt="upload successful">  </p><p>把中间十位算出来 为PT的索引</p><p>最后低十位的是04d 是页内偏移  </p><p><img src="/images/pasted-77.png" alt="upload successful"></p><p>然后可以看cr3这个寄存器中的内容, 其中存放的是PD的基地址(cr3 的高20为就是PD基地址的高20位, 低12位为0)</p><p><img src="/images/pasted-78.png" alt="upload successful">  </p><p>然后这里我们按照上面的步骤来, 首先要找到PDE, 也即是说, 这里是需要用ca83000+3e3*4 来找到对应的PDE(因为前面说过, 线性地址的高10位是PDE的索引, 类似c语言中数组的下标, 而每一个PDE是32bit,也就是4byte,所以这里需要用这个索引值乘来找到对应的位置, 这里想不通的同学可以回忆一下, 在计算机中, 一个地址对应存储的是一个字节)   </p><p>这里计算完成之后, 结果位0ca83f8c ,其对应地址存储的是0101a163, 这个就是我们要找的PDE  </p><p>PDE的高20bit为PT起始的高20bit, 也就是说, 我们要用0101a000来作为PD基地址, 而PDE的低12bit为页表属性, 这里其实关注一下它是否指向的是4MB大内存页就可以了, 如果不是就直接去找它对应的PTE, PTE也是4byte, 所以找法是0x0101a000+4*2e,这里的2e就是线性地址的中间十位  </p><p><img src="/images/pasted-79.png" alt="upload successful">  </p><p>然后可以看到这里PTE中存储的内容是0d566163。PTE高20bit指向的是内存页起始地址的高20bit, 即目标地址所在的内存页的基地址为0x0d566000, 低12bit代表的是内存也的属性  </p><p>这里0x0d566000加上前面线性地址的低十位（页内偏移）计算出来的就是真实的物理地址了，结果为0d56604d</p><p><img src="/images/pasted-80.png" alt="upload successful">  </p><p>在windbg中使用!pte可以直接看到这些结果, PTEcontains中高20位就是内存页的起始地址, 也就是下面的pfn的内容, pfn加上线性地址的低12位就可以定位到物理地址了  </p><h2 id="PAE分页"><a href="#PAE分页" class="headerlink" title="PAE分页"></a>PAE分页</h2><p>PAE分页相较于经典的分页来说, PD和PDE都从32bit拓展到64bit, 这样物理地址就可以拓展到64GB, 并且原来的二级页表结构更改为了三级结构, 现在多加了一级页目录指针表(Page Directory Pointer Table, PDPT), 这里的PDPT包含四个64bit的PD, 每个PD描述1GB的线性空间, 4个PD可以描述4GB的线性空间。</p><h2 id="大内存页"><a href="#大内存页" class="headerlink" title="大内存页"></a>大内存页</h2><p>之前提到了PDE指向的不仅仅是PT，有可能指向一个4MB的大内存页（当PS位为1时，代表pagesize为4MB）。  </p><p> + </p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深入理解计算机系统</tag>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开发: flask框架连接mysql数据库</title>
    <link href="/2024/05/09/%E5%BC%80%E5%8F%91-flask%E6%A1%86%E6%9E%B6%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2024/05/09/%E5%BC%80%E5%8F%91-flask%E6%A1%86%E6%9E%B6%E8%BF%9E%E6%8E%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先安装Flask, PyMySQL,Flask-SQLalchemy  ,这些通过pip都可以直接安装  </p><h3 id="配置工作"><a href="#配置工作" class="headerlink" title="配置工作"></a>配置工作</h3><p>首先需要一个URI的配置,以下是URI连接时用到的配置信息  </p><table><thead><tr><th align="center">占位符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">dialect</td><td align="center">数据库，如：sqlite、mysql、oracle等</td></tr><tr><td align="center">driver</td><td align="center">数据库驱动，如前面安装的：pymysql</td></tr><tr><td align="center">username</td><td align="center">登录数据库用户名</td></tr><tr><td align="center">password</td><td align="center">登录数据库密码</td></tr><tr><td align="center">host</td><td align="center">数据库部署 IP 地址</td></tr><tr><td align="center">port</td><td align="center">端口</td></tr><tr><td align="center">database</td><td align="center">数据库库名</td></tr></tbody></table><p>而URI字符串构造形式为<br><code>dialect+driver://username:password@host:port/database</code>  </p><p>在Flask类中, 还有一个对象叫config对象, 该属性是一个dict, 需要进行相应的配置使其生效<br>例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python">DB_URI = <span class="hljs-string">&#x27;mysql+pymysql://root:passwd@localhost:3306/school&#x27;</span><br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = DB_URI<br><span class="hljs-comment">#数据库追踪</span><br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_TRACK_MODIFICATIONS&#x27;</span>] = <span class="hljs-literal">False</span><br><span class="hljs-comment">#显示底层语句</span><br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_ECHO&#x27;</span>] = <span class="hljs-literal">True</span><br><br>```  <br><br>这里的config具体配置还可以从JSON文件导入, 实现配置分离  <br><br>```python<br><span class="hljs-keyword">import</span> json<br>app.config.from_file(<span class="hljs-string">&quot;config.json&quot;</span>, load=json.load)<br>```  <br><br><br><span class="hljs-comment">### 建立上下文 ###  </span><br><br><br>这里好像是出于程序安全性考虑, 连接到数据库必须存在上下文, 所以需要一个基本的flask网页  <br><br>向代码中添加index控制器  <br><br>```python<br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    sql =  text(<span class="hljs-string">&#x27;SELECT * FROM school.course;&#x27;</span>)<br>    result = db.session.execute(sql)<br>    courses = result.fetchall()<br>    <span class="hljs-built_in">print</span>(courses)<br>    <span class="hljs-keyword">return</span> flask.render_template(<span class="hljs-string">&#x27;index.html&#x27;</span>, courses=courses)<br><br></code></pre></td></tr></table></figure><p>在程序根目录下的templates文件夹中创建index.html, 随便写点东西, 保证文件存在就行  </p><p>随后就可以测试了   </p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>完整代码  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> flask<br><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask<br><span class="hljs-keyword">from</span> flask_sqlalchemy <span class="hljs-keyword">import</span> SQLAlchemy<br><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> text<br>app = Flask(__name__)<br>DB_URI = <span class="hljs-string">&#x27;mysql+pymysql://root:passwd@localhost:3306/school&#x27;</span><br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_DATABASE_URI&#x27;</span>] = DB_URI<br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_TRACK_MODIFICATIONS&#x27;</span>] = <span class="hljs-literal">False</span><br>app.config[<span class="hljs-string">&#x27;SQLALCHEMY_ECHO&#x27;</span>] = <span class="hljs-literal">True</span><br>db = SQLAlchemy(app)<br><br><span class="hljs-meta">@app.route(<span class="hljs-params"><span class="hljs-string">&#x27;/&#x27;</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">index</span>():<br>    sql =  text(<span class="hljs-string">&#x27;SELECT * FROM school.course;&#x27;</span>)<br>    result = db.session.execute(sql)<br>    courses = result.fetchall()<br>    <span class="hljs-built_in">print</span>(courses)<br>    <span class="hljs-keyword">return</span> flask.render_template(<span class="hljs-string">&#x27;index.html&#x27;</span>, courses=courses)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">with</span> app.app_context():<br>        app.run()<br><br><br></code></pre></td></tr></table></figure><p>运行之后, 就可以在终端中查看数据库的输出了, 这里是因为我本地已经创建过一个school数据库, 里面有一些表(做学校数据库实验的时候搞的) 所以在复现本实验的时候需要自己创建一个数据库,并修改查询语句来保证程序正确运行  </p><p><img src="/images/pasted-66.png" alt="运行结果">  </p><p>可以看到console中输出了查询的结果</p>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发技巧</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WriteUp: 2024蓝桥杯</title>
    <link href="/2024/04/28/WriteUp-2024%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    <url>/2024/04/28/WriteUp-2024%E8%93%9D%E6%A1%A5%E6%9D%AF/</url>
    
    <content type="html"><![CDATA[<p>记录一下这一场比赛, 说实话协会内对蓝桥杯还是很抵触的 , 但是为了协会的发展和社团的转正也是没有办法, 毕竟学校对蓝桥杯的认可度比DEFCON都高，如果没有什么成绩协会肯定是办不下去的，这里简单记录一下蓝桥杯的两道逆向(仅有的两道)  </p><p>顺便一提，蓝桥杯没有web题还是非常爽的，爱了</p><h2 id="happytime"><a href="#happytime" class="headerlink" title="happytime"></a>happytime</h2><p>看一下文件格式，是一个ELF格式的文件，题目提示说是个TEA，但是看了下代码实际上并不是一个标准的TEA</p><p><img src="/images/pasted-62.png" alt="upload successful">  </p><p>这里看到没有去除符号表, 函数也是一眼就看出来哪个是主要逻辑了  </p><p>看到cry里面, 这里简单对变量进行了命名  </p><p>这里对该函数仔细分析一下, 函数主要是做一个循环, 循环次数是415 &#x2F; length + 114次, 可以看到这里也是出题人的恶趣味, 然后就是sum每次都是减一个很经典的数字, 这个用findcrypto也是能识别出来是TEA的。  </p><p>然后就是函数具体的加密部分了，这里的核心加密语句为：<br><code>*v1 += ((next ^ sum) + (lastv ^ *(_DWORD *)(4LL * (index ^ i &amp; 3) + key))) ^ (((4 * next) ^ (lastv &gt;&gt; 5))+ ((next &gt;&gt; 3) ^(16 * lastv)));</code>  </p><p>这里可以做个实验, 这里对v1的运算是可逆的, 也就是说原本加了多少数, 如果想还原密文的话减掉那个数就可以了  </p><p>然后再看, 每一轮运算里是有一个for循环, for结束后又执行了一个语句 </p><p><code>    *v2 += ((*input ^ sum) + (lastv ^ *(_DWORD *)(4LL * (index ^ i &amp; 3) + key))) ^ (((4 * *input) ^ (lastv &gt;&gt; 5)) + ((*input &gt;&gt; 3) ^ (16 * lastv)));</code></p><p>这个语句和上一条语句可以看到一些差距, 最主要的就是input的取值, 一个是取input[i+1], 另一个是取input[0], 这里就可以分析出, 一轮加密干的事情是用input[i+1]给input[i]加密, 当i等于10时(也就是length - 1 ), 此时由于并不存在一个input[i+1], 所以就需要使用input[0]来给input[i]做加密, 还有一个需要注意的是lastv这个值, lastv初始值是input[length-1], 也就是input的最后一个值, 进入一轮加密后lastv在每一轮加密后变为当前的值 换句话说, 每一轮的加密都需要用input[i-1]和input[i+1]来给input[i]做加密. 那么逻辑分析出来, 逆向就很容易了, 对于每一轮的操作, 首先要先将lastv置为input[length-2], next置为input[0], 将input[i-1]恢复出来, 然后再进入一个从length -2 到 0 的循环, 这里每一轮循环使用input[i-1]和input[i+1]来恢复input[i], 当i等于0的时候, lastv应该是input[length-1], 这里需要注意一下  </p><p>然后就是最坑爹的地方了, 请看图  </p><p><img src="/images/pasted-64.png" alt="upload successful">  </p><p>当时比赛的时候没做出来主要是栽在这了, 这里调用的时候往里头传的这个key是一个int64的数, 而使用的时候直接是把key作为一个64位的数在用, 也就是说这里的key其实就是一个整数而不是一个指针类型, 所以在IDA中使用这个key的时候使用了类型转换将其转换成了int32类型(也就是DWORD) 所以当时写脚本的时候没注意类型,直接从ida里面复制的代码, 直接执行的 , 所以就导致没把误把key当做了一个int*, 所以就没把flag整出来, 太蠢了  </p><p>剩下一个就是端序的问题, 这题好像默认就是小端绪, 所以直接把密文复制出来从最低位输出就能出flag  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-comment">//decry.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> length = <span class="hljs-number">11</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> input[<span class="hljs-number">12</span>];<br><span class="hljs-type">int</span> key[<span class="hljs-number">4</span>];<br><span class="hljs-type">int</span> index;<br><span class="hljs-type">int</span> turn = <span class="hljs-number">415</span> / length + <span class="hljs-number">114</span>;<br><br><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sum = <span class="hljs-number">1387842591</span> ;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> lastv = input[length - <span class="hljs-number">2</span>];<br><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>input[<span class="hljs-number">0</span>] = <span class="hljs-number">1208664588</span>;<br>input[<span class="hljs-number">1</span>] = <span class="hljs-number">0xCE9037F2</span>;<br>input[<span class="hljs-number">2</span>] = <span class="hljs-number">0x8C212018</span>;<br>input[<span class="hljs-number">3</span>] = <span class="hljs-number">244490637</span>;<br>input[<span class="hljs-number">4</span>] = <span class="hljs-number">0xA4035274</span>;<br>input[<span class="hljs-number">5</span>] = <span class="hljs-number">611560113</span>;<br>input[<span class="hljs-number">6</span>] = <span class="hljs-number">0xA9EFDB58</span>;<br>input[<span class="hljs-number">7</span>] = <span class="hljs-number">0xA52CC5C8</span>;<br>input[<span class="hljs-number">8</span>] = <span class="hljs-number">0xE432CB51</span>;<br>input[<span class="hljs-number">9</span>] = <span class="hljs-number">3494810147</span>;<br>input[<span class="hljs-number">10</span>] = <span class="hljs-number">1875931283</span>;<br>cout&lt;&lt;(<span class="hljs-type">int</span>)input[<span class="hljs-number">4</span>]&lt;&lt;endl;<br>key[<span class="hljs-number">0</span>] = <span class="hljs-number">2036950869</span>;<br>key[<span class="hljs-number">1</span>] = <span class="hljs-number">1731489644</span>;<br>key[<span class="hljs-number">2</span>] = <span class="hljs-number">1763906097</span>;<br>key[<span class="hljs-number">3</span>] = <span class="hljs-number">1600602673</span>;<br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=turn;j++)&#123;<br>lastv = input[length - <span class="hljs-number">2</span>];<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *v1,next;<br>index = (sum &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span>;<br>v1 = &amp;input[length - <span class="hljs-number">1</span>];<br><br><span class="hljs-type">int</span> l1=(index ^ <span class="hljs-number">10</span> &amp; <span class="hljs-number">3</span>);<br><br>*v1 -= ((*input ^ sum) + (lastv ^key[l1] )) ^ (((<span class="hljs-number">4</span> * *input) ^ (lastv &gt;&gt; <span class="hljs-number">5</span>))+ ((*input &gt;&gt; <span class="hljs-number">3</span>) ^ (<span class="hljs-number">16</span> * lastv)));<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=length <span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-keyword">if</span>(i!=<span class="hljs-number">0</span>)&#123;<br>lastv = input[i<span class="hljs-number">-1</span>];<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>lastv = input[length<span class="hljs-number">-1</span>];<br>&#125;<br>next = input[i+<span class="hljs-number">1</span>];<br>v1 = &amp;input[i];<br><br><br><br><span class="hljs-type">int</span> l=(index ^ i &amp; <span class="hljs-number">3</span>);<br>*v1 -= ((next ^ sum) + (lastv ^ key[l])) ^ (((<span class="hljs-number">4</span> * next) ^ (lastv &gt;&gt; <span class="hljs-number">5</span>))+ ((next &gt;&gt; <span class="hljs-number">3</span>) ^ (<span class="hljs-number">16</span> * lastv)));<br><br> <br>&#125;<br><br><br><br>sum+= <span class="hljs-number">0x61C88647</span>;<br><br>&#125;<br><br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10</span>;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)&#123;<br>cout&lt;&lt;(<span class="hljs-type">char</span>)((input[i]&gt;&gt;(<span class="hljs-number">8</span>*j))&amp;<span class="hljs-number">0xff</span>);<br>&#125;<br>&#125;<br>cout&lt;&lt;sum&lt;&lt;endl;<br><br><br><br>&#125;<br><br><br><br><br><br>```C++  加密脚本, 推测源代码就长这样, 这里的密文是flag&#123;xxxxxxxxxxxxxxxxxxxxxxxxx&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _DWORD unsigned int </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> length = <span class="hljs-number">11</span>;<br><br>__int64 key[<span class="hljs-number">4</span>]; <span class="hljs-comment">// [rsp+10h] [rbp-F0h] BYREF</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> input[<span class="hljs-number">12</span>]; <span class="hljs-comment">// [rsp+20h] [rbp-E0h]</span><br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>key[<span class="hljs-number">0</span>] = <span class="hljs-number">2036950869</span>;<br>key[<span class="hljs-number">1</span>] = <span class="hljs-number">1731489644</span>;<br>key[<span class="hljs-number">2</span>] = <span class="hljs-number">1763906097</span>;<br>key[<span class="hljs-number">3</span>] = <span class="hljs-number">1600602673</span>;<br><br>input[<span class="hljs-number">0</span>] = <span class="hljs-number">0x666c6167</span>;<br>input[<span class="hljs-number">1</span>] = <span class="hljs-number">0x7b787878</span>;<br>input[<span class="hljs-number">2</span>] = <span class="hljs-number">0x78787878</span>;<br>input[<span class="hljs-number">3</span>] = <span class="hljs-number">0x78787878</span>;<br>input[<span class="hljs-number">4</span>] = <span class="hljs-number">0x78787878</span>;<br>input[<span class="hljs-number">5</span>] = <span class="hljs-number">0x78787878</span>;<br>input[<span class="hljs-number">6</span>] = <span class="hljs-number">0x78787878</span>;<br>input[<span class="hljs-number">7</span>] = <span class="hljs-number">0x78787878</span>;<br>input[<span class="hljs-number">8</span>] = <span class="hljs-number">0x78787878</span>;<br>input[<span class="hljs-number">9</span>] = <span class="hljs-number">0x78787878</span>;<br>input[<span class="hljs-number">10</span>] = <span class="hljs-number">0x7878787d</span>;<br><br><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *v1; <span class="hljs-comment">// rax</span><br>_DWORD *v2; <span class="hljs-comment">// rax</span><br>__int64 result; <span class="hljs-comment">// rax</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> lastv; <span class="hljs-comment">// [rsp+20h] [rbp-18h]</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sum; <span class="hljs-comment">// [rsp+24h] [rbp-14h]</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i; <span class="hljs-comment">// [rsp+28h] [rbp-10h]</span><br><span class="hljs-type">int</span> turn; <span class="hljs-comment">// [rsp+2Ch] [rbp-Ch]</span><br><span class="hljs-type">int</span> index; <span class="hljs-comment">// [rsp+30h] [rbp-8h]</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> next;<br>turn = <span class="hljs-number">415</span> / length + <span class="hljs-number">114</span>;<br>turn =<span class="hljs-number">3</span>;<br>sum = <span class="hljs-number">0</span>;<br>lastv = input[length - <span class="hljs-number">1</span>];<br><span class="hljs-keyword">do</span><br>&#123;<br>sum -= <span class="hljs-number">0x61C88647</span>;<br>index = (sum &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">1</span>; ++i )<br>&#123;<br>next = input[i + <span class="hljs-number">1</span>];<br>v1 = &amp;input[i];<br><span class="hljs-keyword">if</span>(i==<span class="hljs-number">9</span>)&#123;<br>cout&lt;&lt;key[(index ^ i &amp; <span class="hljs-number">3</span>)]&lt;&lt;endl;<br>cout&lt;&lt;( ((*input ^ sum) + (lastv ^ key[(index ^ i &amp; <span class="hljs-number">3</span>)])) ^ (((<span class="hljs-number">4</span> * *input) ^ (lastv &gt;&gt; <span class="hljs-number">5</span>))+ ((*input &gt;&gt; <span class="hljs-number">3</span>) ^ (<span class="hljs-number">16</span> * lastv))))&lt;&lt;endl;<br><br>&#125;<br> *v1 += ((next ^ sum) + (lastv ^ key[(index ^ i &amp; <span class="hljs-number">3</span>)])) ^ (((<span class="hljs-number">4</span> * next) ^ (lastv &gt;&gt; <span class="hljs-number">5</span>))+ ((next &gt;&gt; <span class="hljs-number">3</span>) ^ (<span class="hljs-number">16</span> * lastv)));<br>lastv = *v1;<br><br><br>&#125;<br>v2 = &amp;input[length - <span class="hljs-number">1</span>];<br>cout&lt;&lt;(index ^ i &amp; <span class="hljs-number">3</span>)&lt;&lt;endl;<br>cout&lt;&lt;*(_DWORD *)(<span class="hljs-number">4LL</span> * (index ^ i &amp; <span class="hljs-number">3</span>) + key)&lt;&lt;endl;<br>*v2 += ((*input ^ sum) + (lastv ^ key[(index ^ i &amp; <span class="hljs-number">3</span>)   ])) ^ (((<span class="hljs-number">4</span> * *input) ^ (lastv &gt;&gt; <span class="hljs-number">5</span>))+ ((*input &gt;&gt; <span class="hljs-number">3</span>) ^ (<span class="hljs-number">16</span> * lastv)));<br>result = (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)*v2;<br>lastv = result;<br>--turn;<br>&#125;<br><span class="hljs-keyword">while</span> ( turn );<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">10</span>;i++)&#123;<br><br>cout&lt;&lt;<span class="hljs-string">&quot;input[&quot;</span>&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot;] = &quot;</span>&lt;&lt;input[i]&lt;&lt;<span class="hljs-string">&quot;;&quot;</span>&lt;&lt;endl;<br><br>&#125;<br>cout&lt;&lt;sum&lt;&lt;endl;<br><br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><h2 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h2><p>白给的题, 动态调试一下, flag是明文的  </p><p><img src="/images/pasted-65.png" alt="upload successful">  </p><p>flag{12601b2b-2f1e-468a-ae43-92391ff76ef3}  </p><p>蓝桥杯虽然收费, 还挺贵, 但至少打着不坐牢, 新手可以打这个练练手, 没啥不好的</p>]]></content>
    
    
    <categories>
      
      <category>WP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>蓝桥杯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记: Mysql语句</title>
    <link href="/2024/04/22/%E6%95%99%E7%A8%8B-Mysql%E8%AF%AD%E5%8F%A5/"/>
    <url>/2024/04/22/%E6%95%99%E7%A8%8B-Mysql%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>本教程致力打造一个mysql最速入门教程, 以最简介的语言教会你如何写sql语句, 适用人员包括但不限于: 即将考试的大学生, 想要了解数据库的产品经理, 想要快速入门sql注入的安全人员</p><p>Mysql中最主要的四个部分是增删改查, 而这四个部分中最主要的部分是查询的部分, 查询语句的写法是最为复杂的, 除此之外Mysql中还有一些关于权限的操作, 这里回一一进行介绍</p><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><h3 id="增加一个数据库"><a href="#增加一个数据库" class="headerlink" title="增加一个数据库"></a>增加一个数据库</h3><p>一台主机中运行一个DBMS, 也就是mysql, 一个DBMS中可以存在多个数据库, 这里介绍如何创建数据库  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> school;<br></code></pre></td></tr></table></figure><p>上面的语句的意思为创建一个名为school的数据库, if not exists为可选项, 代表如果该数据库不存在才进行创建, 如果存在就不创建, 这么做的原因是防止报错  </p><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>创建一个表使用如下语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs sql"><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">TABLE</span> student(<br><br>    Sno <span class="hljs-type">CHAR</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">UNIQUE</span>,<br>    Sname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">8</span>),<br>    Ssex <span class="hljs-type">CHAR</span>(<span class="hljs-number">2</span>),<br>    Sage <span class="hljs-type">SMALLINT</span> <span class="hljs-keyword">check</span>(Sage <span class="hljs-operator">&gt;</span><span class="hljs-number">18</span>),<br>    Sdept <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">15</span>)  <span class="hljs-keyword">DEFAULT</span>(&quot;JSJ&quot;),<br>    <span class="hljs-keyword">PRIMARY</span> KEY(Sno)<br><br>);<br><br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">TABLE</span> course(<br>    Cno <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    Cname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>),<br>    Cpno <span class="hljs-type">CHAR</span>(<span class="hljs-number">4</span>),<br>    Ccredit TINYINT,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (Cno) <br><br>)<br><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">TABLE</span> sc(<br><br>    Sno <span class="hljs-type">CHAR</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br>    Cno <span class="hljs-type">CHAR</span>(<span class="hljs-number">6</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>,<br><br>    Grade <span class="hljs-type">DECIMAL</span>(<span class="hljs-number">12</span>,<span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">PRIMARY</span> KEY (Sno,Cno)<br>    <span class="hljs-keyword">CONSTRAINT</span> FK_student_sno (Sno) <span class="hljs-keyword">FOREIGN</span> KEY <span class="hljs-keyword">REFERENCES</span> student(Sno),<br><br>    <span class="hljs-keyword">CONSTRAINT</span> FK_student_Cno (Cno)  <span class="hljs-keyword">FOREIGN</span> KEY <span class="hljs-keyword">REFERENCES</span> student(Cno)<br>    <br><br>);<br><br><br><br></code></pre></td></tr></table></figure><p>我们来看上面的语句, 一一进行解释</p><p>首先是 not null 这个语句的意思是约束这个表的这一列不为空  </p><p>unique代表这一列是独一无二的, 不能重复的</p><p>创建一个表的时候, 列名的后面是这个列的数据类型,这里DECIMAL(12,1) 的意思是一个十二位的数字, 其中小数占1位  </p><p>constraint 代表着建立一个约束, 后面跟着的是这个约束的名称, 名称后面是这个约束的具体内容, 像这里的sc表就建立了一个外键约束, sno列参考student里的sno列, cno列参考student的cno列, 这里还可以设定其在变化时的操作,例如 在更新时执行casecade 之类的操作</p><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><h3 id="删除一个数据库"><a href="#删除一个数据库" class="headerlink" title="删除一个数据库"></a>删除一个数据库</h3><p>删除数据库使用语句:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> database if <span class="hljs-keyword">exists</span> schools;<br></code></pre></td></tr></table></figure><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><h3 id="修改一个数据库"><a href="#修改一个数据库" class="headerlink" title="修改一个数据库"></a>修改一个数据库</h3>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验: MFC逆向</title>
    <link href="/2024/04/14/%E5%AE%9E%E9%AA%8C-MFC%E9%80%86%E5%90%91/"/>
    <url>/2024/04/14/%E5%AE%9E%E9%AA%8C-MFC%E9%80%86%E5%90%91/</url>
    
    <content type="html"><![CDATA[<p>首先, MFC是有消息映射和消息分发队列的, 这就导致其反编译出的代码不是那么好看, 所以对于MFC这种程序的逆向就会稍微有别于普通的程序, 这里以清华MLM模型提供的示例程序为例演示MFC逆向的基本流程</p><p>(后续如果有机会的话可能会写一篇关于MLM的使用测评)</p><h3 id="在IDA中导入MFC函数的结构体"><a href="#在IDA中导入MFC函数的结构体" class="headerlink" title="在IDA中导入MFC函数的结构体"></a>在IDA中导入MFC函数的结构体</h3><p> MFC的消息映射类型都是长这个样的</p><p> 消息映射入口<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AFX_MSGMAP_ENTRY</span></span><br><span class="hljs-class">&#123;</span><br>  UINT nMessage;<br>  UINT nCode;<br>  UINT nID;<br>  UINT nLastID;<br>  UINT_PTR nSig;<br>  <span class="hljs-type">void</span> (*pfn)(<span class="hljs-type">void</span>);<br>&#125;;<br><br><br></code></pre></td></tr></table></figure></p><p> 消息映射<br> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AFX_MSGMAP</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">const</span> AFX_MSGMAP *(__stdcall *pfnGetBaseMap)();<br>  <span class="hljs-type">const</span> AFX_MSGMAP_ENTRY *lpEntries;<br>&#125;;<br><br> <br></code></pre></td></tr></table></figure></p><p> 在view -&gt; subview 中找到localtype, 插入这两个结构体, 并同步到idb中去(这样才会对反编译的代码生效)</p><p><img src="/images/pasted-53.png" alt="upload successful"></p><h3 id="查找人工手写的函数"><a href="#查找人工手写的函数" class="headerlink" title="查找人工手写的函数"></a>查找人工手写的函数</h3><p>这里一般是需要对MFC的函数地址进行查询, 一般是使用XSPY对桌面窗口的句柄进行查询, 但是这里XSPY不知道为啥查不出该程序的函数, 所以只能自己去手动找了</p><p><img src="/images/pasted-54.png" alt="upload successful">  </p><p>这里的话只能是按照经验去找了, 这里MFC的消息映射结构一般都是这个样子的, 一大堆db数据,有很多0 ,并且时不时会出现一个地址, 一般跟在一大堆库MFC库函数后面的, 且都在rdata段</p><p>点edit -&gt; struct var 给该段转换为我们刚刚插入的结构体, 一般是先插入一个AFX_MSGMAP, 然后再插入若干个AFX_MSGMAP_ENTRY 这样,这里的AFXMSGMAP起到的是一个表头的作用, 转换完结构后IDA中的代码就会变成这样  </p><p><img src="/images/pasted-55.png" alt="upload successful">  </p><p>那我们此时就能看到, 转换完后的最后一个成员变量就是函数地址, 双击即可跟入了</p><p>上面的操作也仅仅做演示, 因为可以看到这么转换完的函数仍然是一个MFC的库函数,并不是什么人工手写的东西</p><p>这里的话往上翻一下, 可以翻到这个 </p><p><img src="/images/pasted-56.png" alt="upload successful"></p><p>这里箭头所指的地方是IDA错误的识别了这个结构, 只识别了一半, 这里需要将它转化为db 然后再应用我们新增的MFX结构体</p><p>至于怎么看出来这个地方需要转化成db的, 也只能说是经验之谈了</p><p><img src="/images/pasted-57.png" alt="upload successful">  </p><p>这里转换完之后就长这样,可以跟进看里面的函数具体的内容</p><p>这里的sub_7FF6A80E1B70 就是主要加密部分了</p><h3 id="逻辑逆向"><a href="#逻辑逆向" class="headerlink" title="逻辑逆向"></a>逻辑逆向</h3><p>这里看下函数, 发现一个哈希加密的东西, 上微软文档看下函数的API</p><p><img src="/images/pasted-59.png" alt="upload successful"></p><p>然后发现是MD5<br><img src="/images/pasted-58.png" alt="upload successful">  </p><p><img src="/images/pasted-60.png" alt="upload successful">  </p><p>这里有一串神秘数字,应该是key,给它md5解密一下  </p><p><img src="/images/pasted-61.png" alt="upload successful">  </p><p>然后发现也是挺白给的密码,这里就逆向结束了  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MFC逆向如果没有混淆或者是其它反逆向手段的话还是很好逆的, 需要注意的是记得常去搜MFC标准函数的文档, 查看这些函数的作用, 反正这个年代的IDA已经能全识别出来了, 虽然MFC已经逐步被淘汰了, MFC逆向似乎没啥企业价值了, 但是你去逆一下某些大学与其教学水平同样落后的学校的软件还是很有用的</p>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C#学习</title>
    <link href="/2024/04/08/C-%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/04/08/C-%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>本人会在这里记录我的C#学习过程中遇到的有意思的问题  </p><hr><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装主要由以下几个修饰符实现:  </p><p>public：所有对象都可以访问, 无论是本文件还是其它引用本文件的文件都可以访问；  </p><p>internal：本文件内的所有对象可以访问；  </p><p>private：只有对象内部可以访问；  </p><p>protected：只有该类对象及其子类对象可以访问  </p><p>protected internal：访问限于当前程序集或派生自包含类的类型。  </p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>c#中的方法与c++的大部分特性都相同, 这里调几个重点的讲下  </p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>看上面的代码里面调用方法时使用了ref关键字, 这个有区别于c++中的引用, c#中需要使用ref关键字来表明这里传递的是一个引用型变量</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">ConsoleApp1</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span>(<span class="hljs-params"><span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> a ,<span class="hljs-keyword">ref</span> <span class="hljs-built_in">int</span> b</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> c = a;<br>            a = b;<br>            b = c;<br>        &#125;  <br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>         &#123;<br>            Program n = <span class="hljs-keyword">new</span> Program(); <span class="hljs-comment">// 这里必须实例化才能调用Program类中的方法</span><br>            <span class="hljs-built_in">int</span> a = <span class="hljs-number">10</span>;<br>            <span class="hljs-built_in">int</span> b = <span class="hljs-number">20</span>;<br>            n.swap(<span class="hljs-keyword">ref</span> a, <span class="hljs-keyword">ref</span> b);<br>            Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, a, b);<br>        &#125;<br>    &#125;<br>&#125;<br>```  <br><br><br><br><br><span class="hljs-meta">### 输出参数</span><br><br><br>这个是c<span class="hljs-meta">#中特有的一个特性, 它跟引用类似, 但是其**不需要赋初始值**也可以传递给函数  </span><br><br>``` C<span class="hljs-meta">#</span><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">ConsoleApp1</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">give</span>(<span class="hljs-params"><span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> a, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> b</span>)</span><br>        &#123;<br>            a = <span class="hljs-number">1001</span>;<br>            b = <span class="hljs-number">2001</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>         &#123;<br>            Program n = <span class="hljs-keyword">new</span> Program();<br>            <span class="hljs-built_in">int</span> c, d;<br>            n.give(<span class="hljs-keyword">out</span> c, <span class="hljs-keyword">out</span> d);<br>            Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, c, d);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码输出<code> 1001 2001</code> , 这里就是使用了输出参数, c和d都被输出了值  </p><p>最后c#中的方法都是写在类里面的, 然后Main这个方法又是一个独立于类的方法(因为它是以static声明的), 在如果在同一个类中又有自己实现的方法又有Main, 那么在Main中调用这个方法必须先实例化   </p><h2 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h2><p>? 单问号用于对 int、double、bool 等无法直接赋值为 null 的数据类型进行 null 的赋值，意思是这个数据类型是 Nullable 类型的。<br><code>e.g int? i = 3; </code></p><p>?? 双问号用于判断一个变量在为 null 的时候返回一个指定的值。  </p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">double</span>? num1 = <span class="hljs-literal">null</span>;<br>num3 = num1 ?? <span class="hljs-number">5.34</span>;      <span class="hljs-comment">// num1 如果为空值则返回 5.34</span><br>Console.WriteLine(<span class="hljs-string">&quot;num3 的值： &#123;0&#125;&quot;</span>, num3);<br>```  <br><br>num3 的值： <span class="hljs-number">5.34</span><br><br><br><br><br><span class="hljs-meta">## 数组  </span><br><br><br><span class="hljs-meta">### 数组的声明</span><br><br>在C<span class="hljs-meta">#中声明数组是用</span><br>`datatype[] arrayName;`语法声明的, C<span class="hljs-meta">#中的数组在初始化的时候不会在内存中存在, 不能直接使用, 必须要使用new关键字对其进行赋值(C#是一个非常面向对象的语言, 一切的数据类型都是对象)   </span><br><br>使用`<span class="hljs-built_in">double</span> arr[] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">double</span>[<span class="hljs-number">10</span>]`来新声明一个数组, 这个数组在经过这个语句赋值之后就可以使用了  <br><br><br>```C<span class="hljs-meta">#</span><br>balance[<span class="hljs-number">0</span>] = <span class="hljs-number">4500.0</span>;<br><span class="hljs-built_in">double</span>[] balance = &#123; <span class="hljs-number">2340.0</span>, <span class="hljs-number">4523.69</span>, <span class="hljs-number">3421.0</span>&#125;;<span class="hljs-comment">//使用初始化容器初始化</span><br><br><br><span class="hljs-built_in">int</span> [] marks = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>]  &#123; <span class="hljs-number">99</span>,  <span class="hljs-number">98</span>, <span class="hljs-number">92</span>, <span class="hljs-number">97</span>, <span class="hljs-number">95</span>&#125;;<span class="hljs-comment">//当然也可以在声明时直接使用初始化容器</span><br><br><br><span class="hljs-built_in">int</span> [] marks = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]  &#123; <span class="hljs-number">99</span>,  <span class="hljs-number">98</span>, <span class="hljs-number">92</span>, <span class="hljs-number">97</span>, <span class="hljs-number">95</span>&#125;; <span class="hljs-comment">//如果使用了初始化容器,则数组的大小是可以忽略的,可以自动推理其长度</span><br><br><br><span class="hljs-built_in">int</span> [] marks = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]  &#123; <span class="hljs-number">99</span>,  <span class="hljs-number">98</span>, <span class="hljs-number">92</span>, <span class="hljs-number">97</span>, <span class="hljs-number">95</span>&#125;;<br><span class="hljs-built_in">int</span>[] score = marks;<span class="hljs-comment">//可以使用这种方式初始化, 但是这种方式的本质和c++中的指针类似, score和marks指向同一个内存地址</span><br><br><br></code></pre></td></tr></table></figure><p>上面的数组都是使用了初始化容器进行初始化, 所以没有指定数组大小也能通过编译,编译器会自动将数组的长度设初始化容器的长度 , 但是在不使用初始化容器的情况下, 必须要在实例化时对数组的大小进行声明,否则无法通过编译</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[] _c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[];<span class="hljs-comment">// 错误, 因为new int后没有指定数组的具体大小</span><br><span class="hljs-built_in">int</span>[] _c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">// 正确</span><br><br></code></pre></td></tr></table></figure><p>除此之外, 数组也可以作为参数传递给函数</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">class</span> <span class="hljs-title">MyArray</span><br>  &#123;<br>     <span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">getAverage</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> size</span>)</span><br>     &#123;<br>        <span class="hljs-built_in">int</span> i;<br>        <span class="hljs-built_in">double</span> avg;<br>        <span class="hljs-built_in">int</span> sum = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; ++i)<br>        &#123;<br>           sum += arr[i];<br>        &#125;<br><br>        avg = (<span class="hljs-built_in">double</span>)sum / size;<br>        <span class="hljs-keyword">return</span> avg;<br>     &#125;<br>  &#125;<br><br></code></pre></td></tr></table></figure><p>这里数组还可以用object来声明，例如  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">object</span>[] objects = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>[<span class="hljs-number">10</span>] &#123; <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&quot;asd&quot;</span>,<span class="hljs-number">1.2</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;;<span class="hljs-comment">//使用初始化容器, 必须给每一项都赋值, 不能少</span><br>objects = [<span class="hljs-number">1</span>,<span class="hljs-string">&quot;asdasd&quot;</span>];<span class="hljs-comment">//给数组赋值可以小于数组长度</span><br></code></pre></td></tr></table></figure><p>这里的对象列表就很像python中的列表, 什么东西都能往里面放, 这其实还是因为C#中所有的类的实例化对象的基类其实都是object</p><h3 id="数组的访问"><a href="#数组的访问" class="headerlink" title="数组的访问"></a>数组的访问</h3><p>访问可以通过下标直接访问, 这一点与c++无异</p><p>当然, C#提供了迭代器来访问数组</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[] n=<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>&#125;<br><span class="hljs-keyword">foreach</span>(<span class="hljs-built_in">int</span> i <span class="hljs-keyword">in</span>  n)&#123;<br><br>Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;&quot;</span>,i)<br>&#125;<br><br>```  <br><br><br>这个东西就和python中的`<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> list`这种语法很像了,n得是一个可迭代对象, i是每个元素  <br><br><br><span class="hljs-meta">### 多维数组  </span><br><br>C<span class="hljs-meta">#中的多维数组和C++不太一样, string 类型的二维数组为:`string [,] names;` int类型的三维数组为`int [ , , ] ;`, 它这是靠方括号里的逗号来确定维度的</span><br><br><br>而访问的时候也不像c++那样要好几个方括号,C<span class="hljs-meta">#访问多维数组是用`m[2,3]`这样的方式访问的, 是方括号里用逗号区分维度的  </span><br><br><br>多维数组也可以赋初始值,其赋值方法为:  <br><br>```C<span class="hljs-meta">#</span><br><span class="hljs-built_in">int</span> [,] a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span> [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>] &#123;<br> &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125; ,   <span class="hljs-comment">/*  初始化索引号为 0 的行 */</span><br> &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125; ,   <span class="hljs-comment">/*  初始化索引号为 1 的行 */</span><br> &#123;<span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>&#125;   <span class="hljs-comment">/*  初始化索引号为 2 的行 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>使用上面的初始化列表嵌套对多维数组进行初始化</p><p>ps. C#中,数组可以使用GetLength方法获取数组的长度, 因为这玩意可以变长,然后这个数组是从Array类继承下来的, 所以想知道数组都有哪些内置方法可以去看下微软文档, 里面还是有蛮多方法的, 排序逆序查找啥的都有[<a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.array?view=net-7.0#methods]">https://learn.microsoft.com/zh-cn/dotnet/api/system.array?view=net-7.0#methods]</a></p><h3 id="交错数组"><a href="#交错数组" class="headerlink" title="交错数组"></a>交错数组</h3><p>c#中的交错数组定义为</p><p><code>int[][] a</code></p><p>此时并没有在内存中为数组分配空间, 如果需要使用该数组, 则需要使用</p><p><code>int [][] a = new int[5][]</code><br>这种方式来为数组分配空间<br>这是因为数组是变长的, 所以可以不指定大小, 但是这里new int关键字后面的第一个秩标识符必须是要确定数组大小的, 否则会报错  </p><p>这是因为交错数组实际上也是一个数组, 只不过数组中的每一个元素都是一个数组, 并且元素数组的长度可以不统一<br>例如  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[][] scores = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>][]&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">92</span>,<span class="hljs-number">93</span>,<span class="hljs-number">94</span>&#125;,<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">85</span>,<span class="hljs-number">66</span>,<span class="hljs-number">87</span>,<span class="hljs-number">88</span>&#125;&#125;;<br></code></pre></td></tr></table></figure><p>这个代码声明了一个int类型的二维交错数组scores, 可以看到scores中的数组长度不是统一的  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-built_in">int</span>[,] scores = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>,<span class="hljs-number">4</span>] &#123;  &#123; <span class="hljs-number">92</span>, <span class="hljs-number">93</span>, <span class="hljs-number">94</span> &#125;,  &#123; <span class="hljs-number">85</span>, <span class="hljs-number">66</span>, <span class="hljs-number">87</span>, <span class="hljs-number">88</span> &#125; &#125;;<span class="hljs-comment">//错误, 因为数组是两行四列, 则数组中每一个元素都必须四个元素的初始化容器(因为需要有四列)</span><br><br><span class="hljs-built_in">int</span>[][] scores = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">2</span>][]&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">92</span>,<span class="hljs-number">93</span>,<span class="hljs-number">94</span>&#125;,<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">85</span>,<span class="hljs-number">66</span>,<span class="hljs-number">87</span>,<span class="hljs-number">88</span>&#125;&#125;;<span class="hljs-comment">//正确, 因为使用交错数组说明scores中每一个元素都是一个数组, 数组的长度不需要满足什么要求</span><br><br><span class="hljs-built_in">int</span>[][] scores = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>][<span class="hljs-number">5</span>] <span class="hljs-comment">// 错误, 不允许交错数组在定义时仅允许第一个秩标识符中有数字, 这么规定是因为交错数组是用来解决在数组中存放数组的问题的, 其原型为int[]  [] , 意思是需要一个int[]类型的数组,而在分配内存空间时, 编译器会从左到右检查语句,当检查到交错数组时, 其只接受后[number][][]....这样形式的字符,也就是说交错数组的第二个位置不能填写数字来规定数组的具体大小</span><br><br><br><span class="hljs-built_in">int</span>[][] a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[][]&#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;,<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>&#125;,<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123; <span class="hljs-number">3</span>, <span class="hljs-number">6</span> &#125;, <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[]&#123; <span class="hljs-number">4</span>, <span class="hljs-number">8</span> ,<span class="hljs-number">12</span>,<span class="hljs-number">23</span>,<span class="hljs-number">43</span>,<span class="hljs-number">45</span>,<span class="hljs-number">2</span>,<span class="hljs-number">32</span>,<span class="hljs-number">23</span>,<span class="hljs-number">35</span>,<span class="hljs-number">2</span>,<span class="hljs-number">32</span>,<span class="hljs-number">532</span>&#125; &#125;;<span class="hljs-comment">//正确, 这里的newint[][]关键字没有填写第一个秩标识符内的数字是因为这个数组进行了初始化, 则数组的长度等于初始化容器的个数, 这个数组长度是编译器自动推理的所以不需要(此处为5)</span><br><br><br><br></code></pre></td></tr></table></figure><p>此处进行一个总结</p><ul><li><p>多维数组和交错数组必须要在实例化时指定其大小, 如果使用了初始化容器则不需要指定大小</p></li><li><p>多维数组一旦规定了其大小, 则元素中每一行的个数都必须与规定大小时相同, 否则编译器报错, 但是交错数组不需要遵守这个规定, 交错数组中的每一个元素都是一个数组, 并且其可以变长(以二维数组为例)</p></li><li><p>在不使用初始化容器的情况下, 多维数组的定义方式为 <code>int[,] a = new int[5,5]</code>;   交错数组的定义方式为 int [][] a &#x3D; new int [5][];  (更高维度的数组类比)</p></li></ul><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><h3 id="null条件运算符"><a href="#null条件运算符" class="headerlink" title="null条件运算符"></a>null条件运算符</h3><p>在实际开发中会遇到很多关于判断特殊数据的地方, 因此会有大量的NULL需要进行检测, 但是如果使用显式的判断语句判断的话就会使代码变得冗长, 所以可以使用null条件运算符 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">foreach</span>(Product p <span class="hljs-keyword">in</span> Product.GetProduct())&#123;<br><span class="hljs-built_in">string</span> name  = p?.name;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的表达式为, 当p不为空时, 才把p.name赋值给name, 这么做有效的防止了空引用现象  </p><p>当然, 之类的null条件运算符是可以传递的  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">foreach</span>(Product p <span class="hljs-keyword">in</span> Product.GetProduct())&#123;<br><span class="hljs-built_in">string</span> relatedName = p?.Related?.Name;<br>&#125;<br>```  <br><br><br><br>这里的relatedName只有在p不为空, 且p的Related属性不为空的情况下才会被赋值  <br><br><br>并且, 这里还可以使用<span class="hljs-literal">null</span>合并运算符来将<span class="hljs-literal">null</span>值反馈给程序  <br><br><br>```C<span class="hljs-meta">#</span><br><span class="hljs-keyword">foreach</span> (Product p <span class="hljs-keyword">in</span> Product.GetProducts()) &#123;<br><span class="hljs-built_in">string</span> name = p?.Name ?? <span class="hljs-string">&quot;&lt;No Name&gt;&quot;</span>;<br><br><br></code></pre></td></tr></table></figure><p>上述代码的效果为: 当p的Name属性为空值时, 将name置为 NoName 这将有助于实现空值检测</p><h3 id="自动实现属性"><a href="#自动实现属性" class="headerlink" title="自动实现属性"></a>自动实现属性</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span>? Price &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><span class="hljs-keyword">public</span> Product Related &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br></code></pre></td></tr></table></figure><p>自动实现属性可以帮助简化代码, 上面的语句等价于</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123;<br><span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125;<br><span class="hljs-keyword">set</span> &#123; name = <span class="hljs-keyword">value</span>; &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>也就是说, 如果填了get和set, 那么这个属性就是可以读或者可以写的</p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>在C#中匿名函数一般是用委托类型实现的, 声明一个lambda表达式的方法如下  </p><p>当想声明一个不带返回值的lambda表达式时, 需要用Action类来声明  </p><p><code>Action&lt;string, string, string&gt; addrow = (a,b,c) =&gt; &#123; &#125;;</code><br>这里action后面尖括号里面的是lamda表达式的参数的类型  </p><p>如果想声明一个带返回值的lambda表达式则需要使用Func类来声明</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#">Func&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; addrow1 = (a, b) =&gt; &#123;<br>    <span class="hljs-built_in">string</span> c = <span class="hljs-string">&quot;123123&quot;</span>;<br>    <span class="hljs-keyword">return</span> c;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这里Func尖括号最后一个类型是返回值的类型  </p><h3 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h3><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">results.Add(<span class="hljs-string">$&quot;Name: <span class="hljs-subst">&#123;name&#125;</span>, Price: <span class="hljs-subst">&#123;price&#125;</span>, Related: <span class="hljs-subst">&#123;relatedName&#125;</span>&quot;</span>);<br><br><br></code></pre></td></tr></table></figure><p>上述代码中, 字符串前加了一个$符号, 代表计算字符串时, 可以使用指定的变量或常量来填充这些槽(hole)  </p><p>像上述代码的槽中, 分别插入了name price relatedName变量, 那么代码会去当前上下文中寻找这些变量并进行替换</p><h2 id="C-高级"><a href="#C-高级" class="headerlink" title="C#高级"></a>C#高级</h2><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>委托的本质和C++中的函数指针非常相似  </p><p>委托是用来实现解耦的, 当一个功能没有完全实现时, 可以使用委托来代替它原本的位置, 从而不影响开发(例如数据库功能, 可以使用委托来实现, 在没有进入数据库相关开发之前可以使用静态内容来实现伪数据库, 在开发完成后可以进行替换)下面举个例子  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//Class1.cs</span><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">delegantTest</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">CAL</span>&lt;<span class="hljs-title">t</span>&gt;(<span class="hljs-params">t a, t b</span>)</span>;<br>    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">class</span> <span class="hljs-title">Class1</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">func</span>(<span class="hljs-params">CAL&lt;<span class="hljs-built_in">int</span>&gt; c</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> c(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//Program.cs</span><br><span class="hljs-keyword">using</span> delegantTest;<br>Console.WriteLine(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>Class1 a =<span class="hljs-keyword">new</span> Class1();<br><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">f1</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a,<span class="hljs-built_in">int</span> b</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br>Console.WriteLine(a.func(f1));<br></code></pre></td></tr></table></figure><p>这里在主程序中定义了一个f1, 然后将f1作为参数传递给了a这个类中的func()</p><p>在Class1.cs中, <code>public delegate int CAL&lt;t&gt;(t a, t b);</code>语句是用户注册委托的, 它就像声明了一个类一样,需要指定一个返回值,和一个参数列表,这里参数列表可以使用泛型, 而实现委托的函数的参数列表和声明委托时必须一致, 实现委托的函数的返回类型必须和声明委托时的返回类型一致。  </p><p>这里官方给出的用法实际上并不是向func中直接传递函数作为参数的，而是使用以下方法<br><code>CAL&lt;int&gt; public static func1 = new CAL&lt;int&gt;(f1);</code><br>然后再<br><code>Console.WriteLine(func1());</code><br>也就是说, 实现委托是在对委托实例化时进行的  </p><p>下面可以再看一个例子</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//Program.cs</span><br><span class="hljs-keyword">using</span> delegantTest;<br><span class="hljs-keyword">using</span> System;<br><br>Console.WriteLine(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">func</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">float</span> b</span>)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>)(a - b);<span class="hljs-comment">//这里参数上的差异是用来理解委托时声明的参数列表和实现委托的函数的参数列表要相同, 否则没办法正确实现委托</span><br>&#125;<br><br>CAL b = <span class="hljs-keyword">new</span> CAL(func);<br><br>Console.WriteLine(b(<span class="hljs-number">10</span>, <span class="hljs-number">29</span>));<br><br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><br><span class="hljs-comment">//Class1.cs</span><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">delegantTest</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">CAL</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">float</span> b</span>)</span>;<br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>像上面的代码在Class中注册了一个委托, 在Program中给委托实例化了, 实例化的时候需要给它传递一个参数, 这里的传递参数也和c++中相似, 如果传递的是一个函数的名称并且没有给其加上括号, 那么就说明传递的是一个类似函数指针的东西。当实例化完成之后就可以用b来执行函数体的功能了(但是说实话这么使用委托跟接口没啥区别, 所以不咋这么用, 委托的主要用法还是将需要更改的部分和不需要更改的部分区分开来,使用委托后如果需要更改函数体的功能只需要改实现委托的部分就好了, 所以最好还是更多的把委托当作函数的参数会好一些)  </p><h3 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h3><p>委托对象可使用 “+” 运算符进行合并。一个合并委托调用它所合并的两个委托。只有相同类型的委托可被合并。”-“ 运算符可用于从合并的委托中移除组件委托。  </p><p>这里可以直接看菜鸟教程上的示例代码, 感觉讲的很清楚 </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">NumberChanger</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span>;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">DelegateAppl</span><br>&#123;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title">TestDelegate</span><br>   &#123;<br>      <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> num = <span class="hljs-number">10</span>;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-built_in">int</span> <span class="hljs-title">AddNum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> p</span>)</span><br>      &#123;<br>         num += p;<br>         <span class="hljs-keyword">return</span> num;<br>      &#125;<br><br>      <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-built_in">int</span> <span class="hljs-title">MultNum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> q</span>)</span><br>      &#123;<br>         num *= q;<br>         <span class="hljs-keyword">return</span> num;<br>      &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getNum</span>()</span><br>      &#123;<br>         <span class="hljs-keyword">return</span> num;<br>      &#125;<br><br>      <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>      &#123;<br>         <span class="hljs-comment">// 创建委托实例</span><br>         NumberChanger nc;<br>         NumberChanger nc1 = <span class="hljs-keyword">new</span> NumberChanger(AddNum);<span class="hljs-comment">//这里创建实例化的原因是因为AddNum和MultNum方法不是静态的, 如果不创建实例内存中是没有这个方法的, 所以必须要创建一个实例才能把事件注册给nc, 或者可以尝试把AddNum和MultNum改成静态方法, 也可以成功注册 </span><br>         NumberChanger nc2 = <span class="hljs-keyword">new</span> NumberChanger(MultNum);<br>         nc = nc1;<br>         nc += nc2;<br>         <span class="hljs-comment">// 调用多播</span><br>         nc(<span class="hljs-number">5</span>);<br>         Console.WriteLine(<span class="hljs-string">&quot;Value of Num: &#123;0&#125;&quot;</span>, getNum());<br>         Console.ReadKey();<br>      &#125;<br>   &#125;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><p>大概就这么个事吧, 委托被合并之后会越并越长的, 并且都是顺序执行, 而且返回的结果是最后一个调用的结果<br><img src="/images/pasted-82.png" alt="upload successful"></p><p>当使用-&#x3D;的时候, 会根据给定的函数名来把调用链上已经加入多播委托的函数删掉, 这里删除的是随机位置删除  </p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件可以理解是基于委托实现的一种编程思想</p><p>这里我看到一个图感觉还挺直观的  </p><p><img src="/images/pasted-90.png" alt="upload successful">  </p><p>上面这个图中可以看到, 订阅者中注册了三个方法给发布者, 发布者触发某个事件之后, 订阅者中注册的方法都会被触发  </p><p>这里给出使用事件的大致流程图, 简单易懂一看就会  </p><p><img src="/images/pasted-91.png" alt="事件的使用方法"></p><h3 id="特性与反射"><a href="#特性与反射" class="headerlink" title="特性与反射"></a>特性与反射</h3><p>特性是类似标签一样的东西, 想自定义一个标签的方法为</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CharacterAttribute</span> : <span class="hljs-title">Attribute</span>&#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里面没有成员变量, 这里的特性名使用了Attribute后缀, 当然也可以不加<br>这里编写完之后, 就可以使用特性了, 特性的使用方法如下  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C#"><br>[<span class="hljs-meta">Character</span>]<br><span class="hljs-keyword">class</span> <span class="hljs-title">Mario</span>&#123;<br><br><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>这样就给Mario类添加了一个特性  </p><p>定义完特性之后就是如何使用特性, 使用的方法是通过反射代码来使用  </p><p>这里需要注意的一个点是, 特性是打在类上的标签, 给一个类打上标签之后就相当于可以更好的去区分这些类是干什么的了  </p><p>而使用属性的方法就叫反射了, 反射指程序可以访问、检测和修改它本身状态或行为的一种能力。</p><p>这里就涉及到一个很有意思的问题, 很多同学不是很理解上面这段话的意思是什么，因为大多数同学对程序检测自身这个东西没有概念，下面抛出一个问题  </p><p><code>如何让一段程序打印出它本身?</code>  </p><p>在很久以前这个问题是被认为是不可实现的, 就比如一段代码 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    print(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>想把这段代码打印出来, 你会选择怎么做?  </p><p>如果只是单纯的把代码做为字符串打印, 那么代码就会变成这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    print(<span class="hljs-string">&quot;#include&lt;stdio.h&gt;\n</span><br><span class="hljs-string">            int main()&#123;\n</span><br><span class="hljs-string">                print(\&quot;Hello World!\&quot;);\n</span><br><span class="hljs-string">            &#125;&quot;</span><br>    );<br>&#125;<br></code></pre></td></tr></table></figure><p>这样就导致代码自身又一次发生改变了，所以代码打印自身在很久以前被认为是无解的（当然现在已经被解决了） </p><p>然后现在再来考虑一个问题，在C++中如何知道一个代码定义的所有的类名？ </p><p>似乎没有这样的方法，所以在C#中就引入了反射技术来解决这个问题，它可以在程序运行的时候动态的检查自身程序集中存在什么东西  </p><p>下面给出一个实例来更好的理解什么是反射</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//Class1.cs</span><br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">TEST</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CharacterAttribute</span> : <span class="hljs-title">Attribute</span> &#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ActionAttribute</span> : <span class="hljs-title">Attribute</span> &#123; &#125;<br>    [<span class="hljs-meta">Character</span>]<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Mario</span><br>    &#123;<br>        [<span class="hljs-meta">Action</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Jump</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Jump&quot;</span>);<br>        &#125;<br>    &#125;<br>    [<span class="hljs-meta">Character</span>]<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Lois</span><br>    &#123;<br>        [<span class="hljs-meta">Action</span>]<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Kill</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;kill&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//Program.cs</span><br><span class="hljs-keyword">using</span> TEST;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Reflection;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MainForm</span><br>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;Type&gt; chetype;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-title">MainForm</span>()</span><br>    &#123;<br>            chetype = Assembly.GetExecutingAssembly().GetTypes().<span class="hljs-comment">//获取程序集中的所有类, 在反射中</span><br>            Where(<br>                t =&gt; t.GetCustomAttributes(<span class="hljs-keyword">typeof</span>(CharacterAttribute), <span class="hljs-literal">false</span>).Any() <span class="hljs-comment">//使用LINQ语句查询, 使所有添加了Character标签的类返回</span><br>            ).ToList();<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Maincode</span>()</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MainForm m = <span class="hljs-keyword">new</span> MainForm();<br>        <span class="hljs-keyword">var</span> selectType = m.chetype[<span class="hljs-number">0</span>];<br>        <span class="hljs-built_in">object</span> selectCharacter = Activator.CreateInstance(selectType);<br>        <span class="hljs-keyword">var</span> SkillMethods = selectType.GetMethods().<br>            Where(m =&gt; m.GetCustomAttributes(<span class="hljs-keyword">typeof</span>(ActionAttribute), <span class="hljs-literal">false</span>)<br><br>            .Any()<br>        ).ToList();<br>        <span class="hljs-keyword">var</span> seskme = SkillMethods[<span class="hljs-number">0</span>];<br>        seskme?.Invoke(selectCharacter, <span class="hljs-literal">null</span>);<span class="hljs-comment">//第二个参数为执行seskme的参数</span><br>    &#125;   <br><br>&#125;<br></code></pre></td></tr></table></figure><p>这里来解释一下上面的代码, 在程序中使用到了LINQ语句, 这里看不懂可以先跳过, 等看完后续学习LINQ语句的部分再回来看  </p><p>首先是Class1.cs中定义了两个类, 分别是Mario和Lois，使用过unity的同学应该能反应过来，在unity中所有的脚本其实都是一个单独的类，这里也可以看做是在 unity中定义了两个角色类 ，这两个角色都有自己的Action，然后使用了特性来给他们加上标签  </p><p>接着就是Program.cs 中的内容, 在MainForm中定义了一个叫chetype的列表, 这个列表中的每一个元素都是一个Type  </p><p>然后在MainForm的构造函数中使用了反射, Assembly就是包含在System.Reflection命名空间中的, GetExecutingAssembly是用于获取当前运行的程序集的, GetTypes用于获取程序集中的所有类型的, 肯定是包括Mario和Lois这两个类的  </p><p>后面使用了一个LINQ查询语句, 意思是对于上面获取到的类型进行迭代, 对于每一个类型, 获取它的特性, 然后再判断是不是我们要的特性, 我们此处要的是CharacterAttribute这个属性, 如果不是这个属性就不会选择到, 最后把选择的属性转化为列表存储到chetype中去  </p><p>在MainCode中包含了一个Main函数作为程序的入口, 这里首先获取到了chetype的第一个元素, 也就是Mario这个类型(注意是类型, 也就是一 个Type)赋值给了selectType, 然后再使用Activator来把这个类实例化<br>(这里的Activator是催化剂\活化剂的意思, 可以理解为这个东西可以帮助一个Type来实例化, 这样就可以调用里面的非静态方法了, 因为我们此时的selectType是一个变量而不是一个类型, 我们没有办法通过 <code>selectType a = new selectType() </code> 这种语句来实例化一个对象, 所以只能用Activator种的相关方法来创建实例)  </p><p>这里创建实例使用的是CreateInstance这个方法, 这个方法接受一个Type作为参数, 返回一个object(C#中object是所有实例化的对象的基类, 这么甚至的原因之一就是在这种需要使用反射的场景中, 并没有办法知道实例化对象的类型, 因为它是一个变量, 可能会因为一些情况发生改变, 所以这里只能用object作为返回值的类型)  </p><p>接下来, 我们获得了一个实例化后的对象, 一个类型(Type 这里是Mario), 我们希望获得这个类型的所有Action 就会使用下面这个语句  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> SkillMethods = selectType.GetMethods().<br>    Where(m =&gt; m.GetCustomAttributes(<span class="hljs-keyword">typeof</span>(ActionAttribute), <span class="hljs-literal">false</span>)<br><br>    .Any()<br>).ToList();<br></code></pre></td></tr></table></figure><p>这个语句长得和上面获取程序集中所有的类几乎一模一样, 区别在于这里GetMethods方法是在selectType中的(Type类型的变量都有这些方法), 我们可以获得一个Type(也就是一个类)所有方法, 然后再使用LINQ语句来对其进行筛选, 找出我们要的加了ActionAttribute标签的方法  , 转化为列表存在 SkillMethods中  </p><p>然后我们就可以尝试让这个Mario的实例来调用这个方法了(没实例化的非静态方法肯定是调用不了的, 所以必须得实例化Mario, 也就是<code>object selectCharacter = Activator.CreateInstance(selectType);</code>这个语句的意义所在 )  </p><p>这里调用的方法是, 先用一个变量seskme来存储前面GetMethods获取到的方法, 这里获取到的是MethodInfo类型, 有了这个MethodInfo就可以通过Invoke来调用这个方法了, 当然前提得是有一个对应的实例, 因为非静态方法肯定是在实例上调用的, Invoke是var类型中带的方法，invoke的第一个参数是实例，第二个参数是一个数组，注意一下C#中的数组是用方括号[]的 </p><p>这里是因为我只给Mario定义了一个方法, 如果Mario有多个方法, 我们还需要找出要调用哪个 , 可以使用如下语句来选择要使用哪个方法, </p><p><code>var seskme = selectCharacter.GetType().GetMethod(SkillMethods[0].Name.ToString());</code></p><p>这里GetMethod可以通过一个字符串来获取想要的方法的MethodInfo, 有了MethodInfo和实例化的对象就可以通过Invoke来执行了  </p><p>上面哪个selectCharacter是一个实例化的对象, 这么写是方便参数传递之类的, 当然在此处也可以直接  </p><p><code>var seskme = selectType.GetMethod(SkillMethods[0].Name.ToString());</code></p><p>也是没啥毛病的</p><p>在C#中, 如何判断一个var是不是我想要的类, 可以使用is来判断  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">var</span> attr;<br><span class="hljs-keyword">if</span>(attr <span class="hljs-keyword">is</span> CharacterAttribute)&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;true&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>接下来, 就需要讲到带参数的特性</p><p>[这里可以看看菜鸟教程懒得写了, 后面有时间加上吧]</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>静态类使用关键字static描述, 使用static的类不能被实例化  </p><p>静态类中声明的方法, 成员啥的都得是static的, static类中的构造函数只能用static修饰, 不能加访问修饰符  </p><p>而静态构造函数就比较有意思，它会在程序开始的时候自动执行无参数的构造函数，静态构造函数必须没有参数（因为这玩意不能实例化，你也没办法往里面传递参数），当然，只有静态类在程序的执行流里才行，不在执行流里就不会被运行构造函数</p><p>然后静态的方法，成员啥的，就算包含这些方法和成员的类不是静态类，外部的程序还是能调用他们  </p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">delegantTest</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CC1</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pcc</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;fuck&quot;</span>);<br>        &#125;<br>    &#125;<br><br><br>&#125;<br><br><br><span class="hljs-comment">// Program.cs</span><br><span class="hljs-keyword">using</span> test;<br>CC1.pcc();<br><br></code></pre></td></tr></table></figure><p>像上面的调用方式是合法的</p><p>静态类型的主要作用就是不需要实例化也可以访问静态类中的方法和成员就跟C++中的全局变量和函数一样</p><p>静态的成员还不能通过实例访问, 就例如上面的代码中, 如果我像下面这样写</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C#"><br>CC1 b = <span class="hljs-keyword">new</span> CC1();<br>Console.WriteLine(b.a);<br><br></code></pre></td></tr></table></figure><p>这种写法就会报错, 因为通过了b这个实例访问了静态成员, 静态成员只能通过类名来访问</p><h2 id="LINQ"><a href="#LINQ" class="headerlink" title="LINQ"></a>LINQ</h2><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化需要给类加上[Serializble]的属性名称, 就代表这个类是可序列化的, 类里面的字段也可以单独规定是否可序列化, 在字段前面加上[Serializable]的属性就可以了  </p><p>如果某个字段不想被序列化, 在前面加上[NonSerialized]即可<br>例如现在有以下代码规定的类, 我们可以将其序列化</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C#">[<span class="hljs-meta">Serializable</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span>  Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    [<span class="hljs-meta">NonSerialized</span>]<br>    <span class="hljs-keyword">public</span> Type t;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pt</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#">Person person = <span class="hljs-keyword">new</span> Person &#123; Name = <span class="hljs-string">&quot;good&quot;</span> &#125;;<span class="hljs-comment">//a new instance</span><br><br><br>BinaryFormatter formatter = <span class="hljs-keyword">new</span> BinaryFormatter();<br>FileStream stream = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-string">&quot;./temp.dat&quot;</span>, FileMode.Create);<br>formatter.Serialize(stream, person);<br>stream.Close();<br></code></pre></td></tr></table></figure><p>使用上面的代码就可以成功将一个类的实例序列化到temp.dat文件中</p><p>如果想从二进制文件中读取这个类的信息, 就可以使用</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C#">stream = <span class="hljs-keyword">new</span> FileStream(<span class="hljs-string">&quot;./temp.dat&quot;</span>, FileMode.Open);<br>Person desp = (Person)formatter.Deserialize(stream);<br>Console.WriteLine(desp.Name);<br></code></pre></td></tr></table></figure><p>这段代码, 反序列化的时候读入的是一个obj对象, 需要对其做类型转换才可以存储到内存中某一个类中去  </p><p>当然, 序列化和反序列化还不止有二进制一种方式, 还有XML序列化和json序列化等方式, 后期会加到这里来</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验: AES算法</title>
    <link href="/2024/03/09/%E5%AE%9E%E9%AA%8C-AES%E7%AE%97%E6%B3%95/"/>
    <url>/2024/03/09/%E5%AE%9E%E9%AA%8C-AES%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>本文主要参考<a href="https://zhuanlan.zhihu.com/p/78913397%E5%92%8Chttps://blog.csdn.net/qq_28205153/article/details/55798628%E4%B8%A4%E7%AF%87%E6%96%87%E7%AB%A0">https://zhuanlan.zhihu.com/p/78913397和https://blog.csdn.net/qq_28205153/article/details/55798628两篇文章</a></p><h1 id="理论部分"><a href="#理论部分" class="headerlink" title="理论部分"></a>理论部分</h1><h2 id="AES算法流程"><a href="#AES算法流程" class="headerlink" title="AES算法流程"></a>AES算法流程</h2><p>首先, AES是需要对输入字节序列进行分组的, 一般是16个字节一组, 也就是128位, 所以本次实验主要以128位的AES为主  </p><p><img src="/images/image_2.png" alt="字节序列排列方式">  </p><p><img src="/images/image_1.png" alt="算法流程图"></p><p>观察上图, 可以发现AES一般是十轮加密, 每一轮有四个操作, 分别是<em>字节代换, shift rows, mix column 密钥加层</em> 在密钥加层会需要用到一次密钥  </p><h2 id="密钥加层"><a href="#密钥加层" class="headerlink" title="密钥加层"></a>密钥加层</h2><p>密钥加层还是比较简单的, 其主要操作为将明文矩阵和子密钥矩阵一一对应的异或一下就好了  </p><p><img src="/images/pasted-39.png" alt="密钥加示意图">  </p><h2 id="字节代换"><a href="#字节代换" class="headerlink" title="字节代换"></a>字节代换</h2><p>字节代换主要是通过一个S_box来将字节进行一次映射, S_box有单独的生成算法, 在加密和解密时会使用不同的S_box  </p><p><img src="/images/pasted-40.png" alt="S_box示意图"></p><p>而代码中实现这个部分也很简单,比较常见的形式是<br><code>PlainArray[i] = S_box[PlainArray[i] &gt;&gt; 4][PlainArray[i] &amp; 0x0F];</code></p><p>上面的代码中, plainArray是一个字节数组, 每一个元素都是8bit, 而字节代换层要求, 对于一个byte元素来说, 其高四位作为映射时的行号,低四位作为列号, 而四位bit刚好可以表示0-15 16个数字, 对应S_box 16*16共256个元素  </p><p><img src="/images/pasted-41.png" alt="字节代换示意图"></p><h2 id="shiftRows"><a href="#shiftRows" class="headerlink" title="shiftRows"></a>shiftRows</h2><p>行位移就是将举证进行循环位移, 第一行不移动, 第二行向左移动1个位置, 第三行向左移动2个位置, 第三行向左移动3个位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//加密时运行的shiftRows代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ShiftRows</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *PlainArray)</span></span><br><span class="hljs-function"></span>&#123;<br><br>  <span class="hljs-comment">//传入的PlainArray是一个从char类型的二维数组,其原型为char PlainArray[4][4] , 将其转换为int*类型时, 每次取值会取连续的4个字节, 也就是AES矩阵中的一行  </span><br>  <br>  <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">//第一行 不移位</span><br>  <span class="hljs-comment">//PlainArray[0] = PlainArray[0];</span><br><br>  <span class="hljs-comment">//第二行 左移8Bit</span><br>  PlainArray[<span class="hljs-number">1</span>] = (PlainArray[<span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">8</span>) | (PlainArray[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">24</span>);<br><br>  <span class="hljs-comment">//第三行 左移16Bit</span><br>  PlainArray[<span class="hljs-number">2</span>] = (PlainArray[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">16</span>) | (PlainArray[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">16</span>);<br><br>  <span class="hljs-comment">//第四行 左移24Bit</span><br>  PlainArray[<span class="hljs-number">3</span>] = (PlainArray[<span class="hljs-number">3</span>] &gt;&gt; <span class="hljs-number">24</span>) | (PlainArray[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">8</span>);<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/images/pasted-42.png" alt="shiftRows图解"></p><p>而其对应的解密操作即为向相反的方向进行位移, 原来向左位移, 则解密时向右位移即可  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//解密时运行的shiftRows代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ReShiftRows</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *CipherArray)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">//第一行 不移位</span><br>  <span class="hljs-comment">//CipherArray[0] = CipherArray[0];</span><br><br>  <span class="hljs-comment">//第二行 右移8Bit</span><br>  CipherArray[<span class="hljs-number">1</span>] = (CipherArray[<span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-number">8</span>) | (CipherArray[<span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">24</span>);<br><br>  <span class="hljs-comment">//第三行 右移16Bit</span><br>  CipherArray[<span class="hljs-number">2</span>] = (CipherArray[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">16</span>) | (CipherArray[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">16</span>);<br><br>  <span class="hljs-comment">//第四行 右移24Bit</span><br>  CipherArray[<span class="hljs-number">3</span>] = (CipherArray[<span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-number">24</span>) | (CipherArray[<span class="hljs-number">3</span>] &gt;&gt; <span class="hljs-number">8</span>);<br><br>  <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>而这里的左移和右移是反直觉的, 这个具体原因涉及到端序的问题, 不清楚的读者可以运行以下代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//运行以下代码, 观察输出情况</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> p[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>]=&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">14</span>,<span class="hljs-number">15</span>&#125;;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><br><br>cout&lt;&lt;*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>])&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">32</span>&gt;(*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>]))&lt;&lt;endl;<br><br>cout&lt;&lt;(*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>])&gt;&gt;<span class="hljs-number">8</span>)&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">32</span>&gt;((*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>])&gt;&gt;<span class="hljs-number">8</span>))&lt;&lt;endl;<br><br>cout&lt;&lt;(*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>])&lt;&lt;<span class="hljs-number">8</span>)&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-built_in">bitset</span>&lt;<span class="hljs-number">32</span>&gt;((*((<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> *)p[<span class="hljs-number">1</span>])&lt;&lt;<span class="hljs-number">8</span>))&lt;&lt;endl;<br><br><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">4</span>;i++)&#123;<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;<span class="hljs-number">4</span>;j++)&#123;<br> <br> cout&lt;&lt;(<span class="hljs-type">int</span>)p[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br> &#125;<br> cout&lt;&lt;endl;<br> &#125;<br> <br> <br>&#125;<br><br></code></pre></td></tr></table></figure><p>在x86架构下, 存储数据时, 是低字节存低位数, 高字节存高位数。例如<br><code>&#123;00,01,02,03&#125;</code>这个数据, 在计算机中按双字存时会显示为  <code>dd 3020100</code>, 因此, 对一个双字元素进行位移操作时, 要考虑端序的问题。  </p><h2 id="mixColumn"><a href="#mixColumn" class="headerlink" title="mixColumn"></a>mixColumn</h2><p>列混淆可以简单理解为, 将输入矩阵与一个混淆矩阵进行乘操作, 在加密时就乘加密矩阵, 解密时乘解密矩阵, 这里的加密矩阵和解密矩阵相乘会得到一个单位矩阵(单位矩阵就跟代数中的数字1是一样的)  </p><p><img src="/images/pasted-43.png" alt="加密矩阵与解密矩阵相乘"></p><p><img src="/images/pasted-44.png" alt="加密时进行的操作"></p><p><img src="/images/pasted-45.png" alt="解密时进行的操作"></p><p>这里的正矩阵和逆矩阵中的数字是标准AES提供的,一般也可以作为特征识别</p><p>只不过这里的乘操作稍微有些复杂, 并不是传统的矩阵乘法, 而是域上的乘法, 关于伽罗瓦域乘法的具体内容这里不展开讲, 因为过于复杂, 我们只需要了解如何进行伽罗瓦域上的乘法即可</p><p>首先, 使用输入矩阵乘加密矩阵相乘 </p><p><img src="/images/pasted-47.png" alt="求状态矩阵"></p><p>然后得到的状态矩阵可以用下图表示 </p><p><img src="/images/pasted-46.png" alt="状态矩阵表示"><br>这里用来连接每一项之间的运算符为伽罗瓦域乘法操作</p><p>这个矩阵中对应的行列其实和标准矩阵乘法的规则是一样的, 都是  </p><p>元素x在矩阵A所在的行中的每一个数字<br>乘<br>元素x在矩阵B所在的列中的每一个数字  </p><p>在伽罗瓦域上的加法是异或,乘法则是按照以下规则进行的  </p><p><img src="/images/pasted-48.png" alt="伽罗瓦域上的乘法">  </p><p>上面这个表达式的意思是, 对于一个8bit的二进制数来说, 如果它的最高位(也就是a7)为0, 那么就直接给他向左移一位就行了, 如果它的最高位是1, 那么就要把它和00011011进行一个异或(这里的00011011也是标准AES提供的, 其具体数值与加密矩阵和解密矩阵有关)  </p><p>而上图中给出的例子是进行了与0x02的乘法, 而这个与0x02的乘法也是最重要的, 因为所有的8bit数都可以拆成和若干个0x02和num相乘的异或式,</p><p>以00001101为例</p><p><img src="/images/pasted-49.png" alt="手写推导"></p><p>在上面的推导过程中,记num’为num这个数和2进行了一次伽罗瓦域乘,我们将其称为变换. </p><p>那么最终的结果就是进行了3次变化的num和进行了2次变化的num和没有进行变换的num相异或的形式.  </p><p>那么观察上面的推导式, 我们其实可以总结出一个规律, 我们将输入的byte记为num, 将进行运算的状态矩阵输入的byte记为mat, 那么对mat这个8bit数中的每一位进行从右到左的检测, 如果该位是0, 那么就说明需要对进行一次变化, 如果最低位是1, 那么就要将当前状态的num计入最终结果的异或式, 那么这么看来, 伽罗瓦域中的乘法就很好实现了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title">GaloisMul</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> mat, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ans = <span class="hljs-number">0</span>; <span class="hljs-comment">//最终组成的异或式的结果</span><br><span class="hljs-keyword">while</span> (mat)<br>&#123;<br><span class="hljs-comment">//如果当前mat的位数是1,那么就将当前状态的num计入最终的异或式</span><br><span class="hljs-keyword">if</span> (mat &amp; <span class="hljs-number">0x01</span>)<br>&#123;<br>ans ^= num;<br>&#125;<br><span class="hljs-comment">//Num_L右移一位，检测mat的下一位</span><br>mat &gt;&gt;= <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//如果当前mat的位数不是1, 那么就说明可以拆一个0x02出来, 那么就可以对式子进行化简, 将num*0x02进行合并, 也就是我们说的进行一次变换</span><br><span class="hljs-keyword">if</span> (num &amp; <span class="hljs-number">0x80</span>)<span class="hljs-comment">//如果num最高位为1</span><br>&#123;<br>num &lt;&lt;= <span class="hljs-number">1</span>;<br>num ^= <span class="hljs-number">0x1B</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>num &lt;&lt;= <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>将伽罗瓦域上的乘法搞定后, 就可以进行运算了, 前面也讲过, 在mixColumn的过程中, 会有两个矩阵, 分别是输入矩阵和给定的状态矩阵, 我们要将这两个矩阵进行域上的乘法来将他们合并, 所以最终的mixColumn的过程为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> MixArray[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>] =<br>&#123;<br><span class="hljs-number">0x02</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>,<br><span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x03</span>, <span class="hljs-number">0x01</span>,<br><span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span>, <span class="hljs-number">0x03</span>,<br><span class="hljs-number">0x03</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x01</span>, <span class="hljs-number">0x02</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">MixColum</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>(*PlainArray)[<span class="hljs-number">4</span>])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//定义变量</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> ArrayTemp[<span class="hljs-number">4</span>][<span class="hljs-number">4</span>];<br><br><span class="hljs-comment">//初始化变量</span><br><span class="hljs-built_in">memcpy</span>(ArrayTemp, PlainArray, <span class="hljs-number">16</span>);<br><br><span class="hljs-comment">//矩阵乘法 4*4</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span>; j++)<br>&#123;<br>PlainArray[i][j] =<br><span class="hljs-built_in">GaloisMul</span>(MixArray[i][<span class="hljs-number">0</span>], ArrayTemp[<span class="hljs-number">0</span>][j]) ^<br><span class="hljs-built_in">GaloisMul</span>(MixArray[i][<span class="hljs-number">1</span>], ArrayTemp[<span class="hljs-number">1</span>][j]) ^<br><span class="hljs-built_in">GaloisMul</span>(MixArray[i][<span class="hljs-number">2</span>], ArrayTemp[<span class="hljs-number">2</span>][j]) ^<br><span class="hljs-built_in">GaloisMul</span>(MixArray[i][<span class="hljs-number">3</span>], ArrayTemp[<span class="hljs-number">3</span>][j]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><p>AES中的密钥是和加密单位矩阵同等规模的矩阵, 加密时输入的矩阵为4*4, 以byte为单位的矩阵, 那么AES最初的密钥也是这个规模  </p><p>当我们观察AES流程图时可以发现, 我们总共会进行十一轮密钥加, 并且每轮密钥加用的密钥都不一样, 但是我们最开始只用了一个16字节的密钥, 那么我们怎么才能搞到那么多的密钥呢, 这时就需要密钥生成算法来为后面几轮的密钥加提供密钥, 密钥生成的流程如下  </p><p>我们可以看到, 这里的密钥都是以列为单位的, 一列4个byte构成一个w, 4个w构成一个子密钥</p><p><img src="/images/pasted-50.png" alt="密钥生成流程图"></p><p>单另拿其中的一部分来看, 进行密钥生成的过程是这样的  </p><p><img src="/images/pasted-51.png" alt="密钥生成具体过程"></p><p>这里的g函数是将四个byte进行向左循环位移, 然后再逐字节进行S_box代换, 代换结束之后需要一个Rcon数组与新密钥的第一个byte进行一次异或</p><p>进行一轮生成后, 可以看到就生成了w4 w5 w6 w7这四组32位的串, 将他们连起来之后就是一个128位的新的密钥</p><h2 id="AES解密流程"><a href="#AES解密流程" class="headerlink" title="AES解密流程"></a>AES解密流程</h2><p><img src="/images/pasted-52.png" alt="解密流程图"></p>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDA交叉引用</title>
    <link href="/2024/03/04/IDA%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8/"/>
    <url>/2024/03/04/IDA%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="代码交叉引用"><a href="#代码交叉引用" class="headerlink" title="代码交叉引用"></a>代码交叉引用</h2><p>在IDA中, 指令转交控制权的方式叫做流, 在IDA中有三种流, 分别是普通流, 跳转流, 和调用流 </p><ol><li><p>普通流<br> 即为顺序执行,指令按照顺序执行就叫普通流  </p></li><li><p>调用流<br> 即为call这样的指令会被分配到一个调用流, 表示将控制权移交给目标函数, 一般情况下call指令也会被分配到一个普通流(在返回时会继续执行后面的指令)  </p></li><li><p>跳转流<br> 类似jmp jz jnz这样的指令会被分配到跳转流, 条件分支还会被分配一个普通流, 以在不进入分支的情况下继续执行代码.</p></li></ol><h2 id="数据交叉引用"><a href="#数据交叉引用" class="headerlink" title="数据交叉引用"></a>数据交叉引用</h2><p>在ida反汇编页面中, 数据的标题行显示的交叉引用的数量是有限制的, 可以在Options -&gt; General -&gt; Cross-reference -&gt; NUmber of displayed xrefs这个地方进行修改  </p><p>数据交叉引用分为三种  </p><ol><li><p>读取交叉引用<br> 在数据段中, ida会以<code>r</code>为结尾的后缀标注出数据引用 <img src="/IDA%E4%BA%A4%E5%8F%89%E5%BC%95%E7%94%A8/image.png" alt="数据段反汇编"><br>在上图中, DATA XREF后面的标识的最后一位, 即为表示该数据交叉引用是什么类型的, main+E↑r这个引用就代表该引用是一个读取交叉引用</p></li><li><p>写入交叉引用, 后缀通常用w表示, 其代表有代码对改数据进行了写入操作  </p></li><li><p>偏移量交叉引用<br>其表示代码引用的是某个位置的地址(而非内容),其后缀为o, 例如全局数组的第一个地址, 或者是一个指针变量等. 偏移量交叉引用不一定是来自指令位置或数据位置, 其有可能来自程序数据部分.<br>例如C++中的虚函数, 如果一个函数是虚函数, 那么其标题行就会显示该函数与虚表的偏移量交叉引用. 并且构造函一般也会使用虚表的地址(如果有虚函数的话), 是可以通过虚表中的偏移量交叉引用找到构造函数的, 在c++中, 虚函数不会被直接引用, 肯定会通过虚表引用的</p></li></ol><h2 id="交叉引用列表"><a href="#交叉引用列表" class="headerlink" title="交叉引用列表"></a>交叉引用列表</h2><p>在subviews窗口中可以打开cross-references窗口, 就能看到完整的交叉引用列表了,当然也可以用快捷键<code>X</code>打开交叉引用窗口  </p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高级C++基础</title>
    <link href="/2024/02/25/c-%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/02/25/c-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>自从学了c++逆向之后我才发现原来我只会c with stl, 因此在这里记录一些高级c++的基础知识。  </p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="1-友元"><a href="#1-友元" class="headerlink" title="1. 友元"></a>1. 友元</h3><p>  友元函数可以访问类中的private和protect成员，声明友元函数只需要在类中添加<code>friend</code>关键字与待声明函数的原型, 例如现有如下函数原型:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, complex a)<br>&#123;<br>  out&lt;&lt;a.m_real&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;a.m_imag&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br>```  <br>该函数是一个输出流运算符重载函数, 我们将他定义在类的外部, 但是这么做就会面临一个问题, 那就是无法输出类中的私有变量, 此时我们就需要对其添加友元属性:  <br><br>```C++<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;<br>  ...<br>  <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, complex a);<br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><br>  上述代码会在类中将重载函数定义为友元函数, 此时该函数就相当于Complex类中定义的函数了。</p><h3 id="2-构造函数与拷贝构造函数"><a href="#2-构造函数与拷贝构造函数" class="headerlink" title="2. 构造函数与拷贝构造函数"></a>2. 构造函数与拷贝构造函数</h3><p>构造函数的形式是  </p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-keyword">class</span> <span class="hljs-title class_">classname</span>&#123;<br><br>  <span class="hljs-title function_">classname</span>(<span class="hljs-params">typename</span> <span class="hljs-params">var</span>)&#123;<br>    <span class="hljs-comment">//code</span><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这个东西是干啥的呢, 比如你有一个代码为<code>classname a=3.14</code>, 那么编译器就会报错, 因为它不知道怎么把一个浮点数赋值给classname, 所以这个时候就需要你在类中定义这么一个构造函数, 来指定赋值时发生的行为。需要注意的是，在声明了一个构造函数后，你的所有<code>=</code>运算符也自动被重载了， 即你想写<code>a=3.14;</code>时，不用额外再写个<code>classname operator=(typename var)&#123;&#125;</code>这么个东西了。</p><p>并且，所有的类在声明时会自动带一个构造函数，这个自带的构造函数是用来处理同类型变量的，假如你有一个classname类型的对象QAQ，那么你想在声明阶段声明一个classname类型的AWA，并且想把这个QAQ的初始值设置为和AWA一样，那么直接写<code>classname AWA=QAQ;</code>即可，不需要重新再写一个构造函数(赋值时也是一样的)，但是假如你想让这个过程发生一些额外的行为，例如你想让AWA等于两倍的QAQ再减一，你就需要对构造函数进行一下重构，编译器自动生成的构造函数只能单纯的进行一次拷贝。</p><p>如果一个构造函数没有参数, 那么在对象创建时会自动调用, 如果有参数, 那么就需要用<code>classname var(par);</code>这种语句。</p><p>在栈上创建对象时，实参位于对象名后面，例如<code>Student stu(&quot;小明&quot;, 15, 92.5f)；</code>在堆上创建对象时，实参位于类名后面，例如<code>new Student(&quot;李华&quot;, 16, 96);</code>。</p><p>构造函数没有返回值，因为没有变量来接收返回值，即使有也毫无用处。</p><p>构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。  </p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//声明运算符重载</span><br><span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> real, <span class="hljs-type">double</span> imag): <span class="hljs-built_in">m_real</span>(real), <span class="hljs-built_in">m_imag</span>(imag)&#123; &#125;<br><br><br><span class="hljs-built_in">complex</span>(<span class="hljs-type">int</span> a)&#123;<br>m_real=<span class="hljs-number">0.0</span>,<br>m_imag=<span class="hljs-number">0.0</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  complex a;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么此时编译器就会报错（因为类中包含了构造函数，而创建对象时却没有调用。），但是把构造函数删掉，编译器就会使用默认的构造函数，反而不会报错了。或者也可以自己手动再添加没有参数的构造函数：<code>complex()&#123;&#125;;</code></p><p>如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。</p><p>一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。</p><p>最后需要注意的一点是，调用没有参数的构造函数也可以省略括号。<code>complex a;</code>和<code>complex a();</code>是一样的。</p><p>拷贝构造函数的形式是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">T</span> (<span class="hljs-type">const</span> T&amp; other_obj)&#123;&#125;<br></code></pre></td></tr></table></figure><p>拷贝构造函数只有一个参数，它的类型是当前类的引用，而且一般都是 const 引用。构造函数的形参必须是引用，但不限制为const，但普遍来说会加上const限制。</p><p>为什么必须是当前类的引用呢？<br>如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入死循环。</p><p>为什么是 const 引用呢？<br>拷贝构造函数的目的是用其它对象的数据来初始化当前对象，并没有期望更改其它对象的数据，添加 const 限制后，这个含义更加明确了。</p><p>另外一个原因是，添加 const 限制后，可以将 const 对象和非 const 对象传递给形参了，因为非 const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为 const 类型不能转换为非 const 类型，这就意味着，不能使用 const 对象来初始化当前对象了。</p><p>拷贝构造函数会在以下三种情况中被调用:  </p><ol><li>用类的一个对象去初始化类的另一个对象时  </li><li>如果函数的形参是类的对象, 调用函数时, 进行形参和实参结合(实参是caller传入的东西, 形参是放在寄存器或栈上的, callee分配的东西)</li><li>如果函数的返回值是类的对象, 函数执行完成返回时(返回时, callee会将要返回的对象拷贝给一个临时变量, 然后销毁callee中的对象, 回到caller的位置再将对象当做返回值返回)</li></ol><h3 id="3-初始化列表"><a href="#3-初始化列表" class="headerlink" title="3. 初始化列表"></a>3. 初始化列表</h3><p>  在写构造函数时, 不仅可以将成员变量在构造函数的函数体中赋值, 也可以将成员变量用初始化列表赋值, 初始化列表的书写方法如下:  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> real, <span class="hljs-type">double</span> imag): <span class="hljs-built_in">m_real</span>(real), <span class="hljs-built_in">m_imag</span>(imag)&#123; &#125;<br><span class="hljs-built_in">complex</span>()&#123;<br>  m_real=<span class="hljs-number">0.0</span>,<br>  m_imag=<span class="hljs-number">0.0</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">double</span> m_real;  <span class="hljs-comment">//实部</span><br>  <span class="hljs-type">double</span> m_imag;  <span class="hljs-comment">//虚部</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>  上述代码中, 两个构造函数的功能类似, 但是采取了两个不同的写法, 第一个构造函数在函数声明和函数体之间多了一个冒号和一个用逗号连接的列表, 具体用法是<code>变量名(表达式)[,变量名(表达式)...]</code><br>  该语句等价于 <code>变量名=表达式</code></p><h2 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h2><p>C++中的引用(reference)使用符号”&amp;”表示, 这个东西看着和C中的取地址符是同一个符号, 但是这两个的作用却不相同, 在C++中引用相当于是一个变量的别名, 使用引用定义的变量和其原变量没有任何区别。  </p><p>例如： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> la;<br><span class="hljs-type">int</span> &amp;a = la;<br></code></pre></td></tr></table></figure><p>使用该定义, 则变量a就是la, 操作a和操作la是一样的, c++在编译时会自动进行优化, 对a的所有操作都会变成直接对la的操作。</p><p>引用的应用有以下几点：</p><h3 id="1-做为函数参数"><a href="#1-做为函数参数" class="headerlink" title="1. 做为函数参数"></a>1. 做为函数参数</h3><p>在当做参数时，应用的参数可以直接操作传入的数字，而不是操作传入参数的拷贝<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span>&#123;<br>a+=<span class="hljs-number">0xcafe</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello_pointer</span><span class="hljs-params">(<span class="hljs-type">int</span> *a)</span></span>&#123;<br>*a+=<span class="hljs-number">0xfe</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hello_ref</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span>&#123;<br>  a+=<span class="hljs-number">0xca</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-type">int</span> a=<span class="hljs-number">10</span>;<br>  <span class="hljs-built_in">hello</span>(a);<br>  <span class="hljs-built_in">hello_pointer</span>(&amp;a);<br>  <span class="hljs-built_in">hello_ref</span>(a);<br>&#125;    <br><br></code></pre></td></tr></table></figure></p><p>上面的三个函数的反编译结果分别是</p>  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs x86ASM">      <span class="hljs-comment">; void __fastcall hello()</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span>                               <span class="hljs-meta">public</span> _Z5helloi<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span>                               _Z5helloi proc <span class="hljs-built_in">near</span>                     <span class="hljs-comment">; CODE XREF: main+19↓p</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span>                                                                       <span class="hljs-comment">; DATA XREF: .pdata:000000014000506C↓o</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span>                               arg_0= <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">10h</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001530</span> <span class="hljs-number">55</span>                            <span class="hljs-keyword">push</span>    <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001531</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> E5                      <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001534</span> <span class="hljs-number">89</span> <span class="hljs-number">4D</span> <span class="hljs-number">10</span>                      <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rbp</span>+arg_0], <span class="hljs-built_in">ecx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001537</span> <span class="hljs-number">81</span> <span class="hljs-number">45</span> <span class="hljs-number">10</span> FE CA <span class="hljs-number">00</span> <span class="hljs-number">00</span>          <span class="hljs-keyword">add</span>     [<span class="hljs-built_in">rbp</span>+arg_0], <span class="hljs-number">0CAFEh</span><br><span class="hljs-symbol">.text:</span>000000014000153E <span class="hljs-number">90</span>                            <span class="hljs-keyword">nop</span><br><span class="hljs-symbol">.text:</span>000000014000153F <span class="hljs-number">5D</span>                            <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001540</span> C3                            <span class="hljs-keyword">retn</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001540</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001540</span>                               _Z5helloi endp<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001540</span><br></code></pre></td></tr></table></figure><p>hello 这个函数中, ecx中存放参数, 可见函数中新建了一个变量arg_0用来存放参数, 说明函数调用的参数是一个拷贝<br>  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs x86ASM">      <span class="hljs-comment">; int *__fastcall hello_pointer(int *)</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                               <span class="hljs-meta">public</span> _Z13hello_pointerPi<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                               _Z13hello_pointerPi proc <span class="hljs-built_in">near</span>           <span class="hljs-comment">; CODE XREF: main+25↓p</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                                                                       <span class="hljs-comment">; DATA XREF: .pdata:000000014000506C↓o</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                                                                       <span class="hljs-comment">; .pdata:0000000140005078↓o</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span>                               arg_0= <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">10h</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001541</span> <span class="hljs-number">55</span>                            <span class="hljs-keyword">push</span>    <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001542</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> E5                      <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001545</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4D</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rbp</span>+arg_0], <span class="hljs-built_in">rcx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001549</span> <span class="hljs-number">48</span> 8B <span class="hljs-number">45</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+arg_0]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000154D</span> 8B <span class="hljs-number">00</span>                         <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">rax</span>]<br><span class="hljs-symbol">.text:</span>000000014000154F <span class="hljs-number">8D</span> <span class="hljs-number">90</span> FE <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>             <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">edx</span>, [<span class="hljs-built_in">rax</span>+<span class="hljs-number">0FEh</span>]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001555</span> <span class="hljs-number">48</span> 8B <span class="hljs-number">45</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+arg_0]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001559</span> <span class="hljs-number">89</span> <span class="hljs-number">10</span>                         <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rax</span>], <span class="hljs-built_in">edx</span><br><span class="hljs-symbol">.text:</span>000000014000155B <span class="hljs-number">90</span>                            <span class="hljs-keyword">nop</span><br><span class="hljs-symbol">.text:</span>000000014000155C <span class="hljs-number">5D</span>                            <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000155D</span> C3                            <span class="hljs-keyword">retn</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000155D</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000155D</span>                               _Z13hello_pointerPi endp<br><span class="hljs-symbol">.text:</span><span class="hljs-number">000000014000155D</span><br></code></pre></td></tr></table></figure></p><p>  hello_pointer函数中, rcx是调用变量的地址, 而寻址后改变的是传入的原变量,能够起到改变传入的变量的效果  </p>  <figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs x86ASM">          <span class="hljs-keyword">int</span> *__fastcall hello_ref(<span class="hljs-keyword">int</span> *)<br><span class="hljs-symbol">.text:</span>000000014000155E                               <span class="hljs-meta">public</span> _Z9hello_refRi<br><span class="hljs-symbol">.text:</span>000000014000155E                               _Z9hello_refRi proc <span class="hljs-built_in">near</span>                <span class="hljs-comment">; CODE XREF: main+31↓p</span><br><span class="hljs-symbol">.text:</span>000000014000155E                                                                       <span class="hljs-comment">; DATA XREF: .pdata:0000000140005078↓o</span><br><span class="hljs-symbol">.text:</span>000000014000155E                                                                       <span class="hljs-comment">; .pdata:0000000140005084↓o</span><br><span class="hljs-symbol">.text:</span>000000014000155E<br><span class="hljs-symbol">.text:</span>000000014000155E                               arg_0= <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span>  <span class="hljs-number">10h</span><br><span class="hljs-symbol">.text:</span>000000014000155E<br><span class="hljs-symbol">.text:</span>000000014000155E <span class="hljs-number">55</span>                            <span class="hljs-keyword">push</span>    <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span>000000014000155F <span class="hljs-number">48</span> <span class="hljs-number">89</span> E5                      <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rbp</span>, <span class="hljs-built_in">rsp</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001562</span> <span class="hljs-number">48</span> <span class="hljs-number">89</span> <span class="hljs-number">4D</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rbp</span>+arg_0], <span class="hljs-built_in">rcx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001566</span> <span class="hljs-number">48</span> 8B <span class="hljs-number">45</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+arg_0]<br><span class="hljs-symbol">.text:</span>000000014000156A 8B <span class="hljs-number">00</span>                         <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">rax</span>]<br><span class="hljs-symbol">.text:</span>000000014000156C <span class="hljs-number">8D</span> <span class="hljs-number">90</span> CA <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>             <span class="hljs-keyword">lea</span>     <span class="hljs-built_in">edx</span>, [<span class="hljs-built_in">rax</span>+<span class="hljs-number">0CAh</span>]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001572</span> <span class="hljs-number">48</span> 8B <span class="hljs-number">45</span> <span class="hljs-number">10</span>                   <span class="hljs-keyword">mov</span>     <span class="hljs-built_in">rax</span>, [<span class="hljs-built_in">rbp</span>+arg_0]<br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001576</span> <span class="hljs-number">89</span> <span class="hljs-number">10</span>                         <span class="hljs-keyword">mov</span>     [<span class="hljs-built_in">rax</span>], <span class="hljs-built_in">edx</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001578</span> <span class="hljs-number">90</span>                            <span class="hljs-keyword">nop</span><br><span class="hljs-symbol">.text:</span><span class="hljs-number">0000000140001579</span> <span class="hljs-number">5D</span>                            <span class="hljs-keyword">pop</span>     <span class="hljs-built_in">rbp</span><br><span class="hljs-symbol">.text:</span>000000014000157A C3                            <span class="hljs-keyword">retn</span><br><span class="hljs-symbol">.text:</span>000000014000157A<br><span class="hljs-symbol">.text:</span>000000014000157A                               _Z9hello_refRi endp<br><br></code></pre></td></tr></table></figure><p>  而hello_ref函数传参是一个引用, 观察代码, 可以发现, 使用引用和使用指针传参是同样的效果,代码完全相同, 这就说明引用其实是编辑器代替你操作指针, 只不过使用引用将会减少代码量并提高代码可读性。  </p><p>指针与引用的区别：</p><ul><li>指针是可以独立存在的; 但是引用不行</li><li>引用必须要进行初始化，指针没有必要</li><li>指针可以设置为NULL， 但是引用不行</li><li>引用一旦进行初始化之后，不会再改变其指向；但指针可以</li></ul><h3 id="2-引用作为函数的返回值"><a href="#2-引用作为函数的返回值" class="headerlink" title="2. 引用作为函数的返回值"></a>2. 引用作为函数的返回值</h3><p>  语法：类型 &amp;函数名（形参列表）{ 函数体 }<br>  1.引用作为函数的返回值时，必须在定义函数时在函数名前加&amp;<br>  2.用引用作函数的返回值的最大的好处是在内存中不产生返回值的副本</p><p>  例如:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">func</span>(<span class="hljs-number">0</span>) = <span class="hljs-number">10</span>;<span class="hljs-comment">// 若func的返回值是一个生命周期大于func的变量时</span><br><span class="hljs-type">int</span> &amp;a = <span class="hljs-built_in">func</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure></p><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><h3 id="1-重载一般运算符"><a href="#1-重载一般运算符" class="headerlink" title="1. 重载一般运算符"></a>1. 重载一般运算符</h3><p>  这里的一般运算符指普通的二元运算符, 例如加减乘除<br>  以下列程序为例:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">complex</span>(<span class="hljs-type">double</span> real, <span class="hljs-type">double</span> imag): <span class="hljs-built_in">m_real</span>(real), <span class="hljs-built_in">m_imag</span>(imag)&#123; &#125;<br>  <span class="hljs-built_in">complex</span>()&#123;<br>    m_real=<span class="hljs-number">0.0</span>,<br>    m_imag=<span class="hljs-number">0.0</span>;<br>  &#125;<br><br><br>  complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> complex &amp;A) <span class="hljs-type">const</span>&#123;<br>    complex B;<br>    B.m_real = <span class="hljs-keyword">this</span>-&gt;m_real + A.m_real;<br>    B.m_imag = <span class="hljs-keyword">this</span>-&gt;m_imag + A.m_imag;<br>    <span class="hljs-keyword">return</span> B;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">double</span> m_real;  <span class="hljs-comment">//实部</span><br>  <span class="hljs-type">double</span> m_imag;  <span class="hljs-comment">//虚部</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">complex::display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>  cout&lt;&lt;m_real&lt;&lt;<span class="hljs-string">&quot; + &quot;</span>&lt;&lt;m_imag&lt;&lt;<span class="hljs-string">&quot;i&quot;</span>&lt;&lt;endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-function">complex <span class="hljs-title">c1</span><span class="hljs-params">(<span class="hljs-number">4.3</span>, <span class="hljs-number">5.8</span>)</span></span>;<br>  <span class="hljs-function">complex <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-number">2.4</span>, <span class="hljs-number">3.7</span>)</span></span>;<br>  complex c3;<br>  c3 = c1 + c2;<br>  c3.<span class="hljs-built_in">display</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>  仔细观察上面的程序, 我们在 complex 类中重载了运算符+，该重载只对 complex 对象有效, 当执行c3 &#x3D; c1 + c2;语句时，编译器检测到+号左边（+号具有左结合性，所以先检测左边）是一个 complex 对象，就会调用成员函数operator+()，也就是转换为下面的形式：<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">c3 = c1.<span class="hljs-keyword">operator</span>+(c2);<br></code></pre></td></tr></table></figure><br>  c1 是要调用函数的对象，c2 是函数的实参。<br>  当然, 上述写法是重载了一个成员函数, 对于运算符的重载也可以变为全局重载:<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">complex <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> complex &amp;A, <span class="hljs-type">const</span> complex &amp;B)&#123;<br>  complex C;<br>  C.m_real = A.m_real + B.m_real;<br>  C.m_imag = A.m_imag + B.m_imag;<br>  <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><br>  当编译器检测到调用时,例如 <strong>c3&#x3D;c1+c2</strong> 加号两边都是complex类型的变量, 那么编译器就会使用如下的调用<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">c3=<span class="hljs-keyword">operator</span>+(c1,c2);<br></code></pre></td></tr></table></figure><br>  <font size=5>将运算符重载函数作为类的成员函数时，二元运算符的参数只有<strong>一个</strong>，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的,默认就是this。</font>  </p><h3 id="2-输入输出流运算符重载"><a href="#2-输入输出流运算符重载" class="headerlink" title="2. 输入输出流运算符重载"></a>2. 输入输出流运算符重载</h3><p>  一般来说, 这类运算符都是在类外部借用友元函数重载的, 具体原因是因为如果在类内部重载, 那么就需要先将对象实例化, 再通过对象来调用运算符, 例如<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Distance</span><br>&#123;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-type">int</span> feet;             <span class="hljs-comment">// 0 到无穷</span><br>        <span class="hljs-type">int</span> inches;           <span class="hljs-comment">// 0 到 12</span><br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">// 所需的构造函数</span><br>        <span class="hljs-built_in">Distance</span>()&#123;<br>            feet = <span class="hljs-number">0</span>;<br>            inches = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-built_in">Distance</span>(<span class="hljs-type">int</span> f, <span class="hljs-type">int</span> i)&#123;<br>            feet = f;<br>            inches = i;<br>        &#125;<br>        ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;( ostream &amp; os)<br>        &#123;<br>            os&lt;&lt;<span class="hljs-string">&quot;英寸：&quot;</span>&lt;&lt;feet&lt;&lt;<span class="hljs-string">&quot;\n英尺：&quot;</span>&lt;&lt;inches;<br>            <span class="hljs-keyword">return</span> os;<br>        &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Distance <span class="hljs-title">d1</span><span class="hljs-params">(<span class="hljs-number">20</span>,<span class="hljs-number">18</span>)</span></span>;<br>    d1&lt;&lt;cout;<span class="hljs-comment">//相当于d1.operator&lt;&lt;(cout)</span><br>&#125;<br>```  <br>这里的就是通过成员函数进行声明, 在使用时, 运算符左值必须为对象。     <br>若不使用成员函数进行重载， 那么就该使用<span class="hljs-keyword">friend</span>关键字先在类中声明函数为友元函数  <br><br>```C++<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">complex</span>&#123;<br>  ...<br>  <span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out , complex a);<br>  ...<br><br>&#125;<br><br>ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, complex a)<br>&#123;<br>  out&lt;&lt;a.m_real&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;a.m_imag&lt;&lt;endl;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>  而返回一个ostream的对象的原因是方便其可以在返回后继续进行输出or输入, 函数的定义也可以看到返回的是一个ostream类型的引用。而这个第一个参数其实是cout这个对象，而cout是在std中定义的对象。  </p><h3 id="3-重载-运算符"><a href="#3-重载-运算符" class="headerlink" title="3. 重载[]运算符"></a>3. 重载[]运算符</h3><p>  C++ 规定，下标运算符[ ]必须以成员函数的形式进行重载。该重载函数在类中的声明格式如下：<code>返回值类型 &amp; operator[ ] (参数);</code></p><p>  或者：<code>const 返回值类型 &amp; operator[ ] (参数) const; </code></p><p>  使用第一种声明方式，[ ]不仅可以访问元素，还可以修改元素。使用第二种声明方式，[ ]只能访问而不能修改元素。在实际开发中，我们应该同时提供以上两种形式，这样做是为了适应 const 对象，因为通过 const 对象只能调用 const 成员函数，如果不提供第二种形式，那么将无法访问 const 对象的任何元素。</p><h3 id="4-重载-运算符"><a href="#4-重载-运算符" class="headerlink" title="4. 重载++ --运算符"></a>4. 重载++ --运算符</h3><p>  这两个都是一元运算符，重载方式如下：<br>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">complex <span class="hljs-keyword">operator</span>++()&#123;<br>  m_real++;<br>  <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<span class="hljs-comment">//++i</span><br><br>complex <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span> n)&#123;<br>  complex s = *<span class="hljs-keyword">this</span>;<br>  m_real++;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<span class="hljs-comment">//i++</span><br></code></pre></td></tr></table></figure><br>  可以看到, 返回值是表达式的结果(基本上所有运算符重载的返回值都是表达式的结果)  </p><p>  而前自增和后自增的区别为是否传参, 后自增的参数<code>int n</code>没有任何意义</p><h3 id="5-C-重载-（强制类型转换运算符）"><a href="#5-C-重载-（强制类型转换运算符）" class="headerlink" title="5. C++重载()（强制类型转换运算符）"></a>5. C++重载()（强制类型转换运算符）</h3><p>在 C++ 中，类型的名字（包括类的名字）本身也是一种运算符，即类型强制转换运算符。</p><p>  类型强制转换运算符是单目运算符，也可以被重载，但只能<em>重载为成员函数</em>，<em>不能重载为全局函数</em>。经过适当重载后，<code>(类型名)对象</code>这个对对象进行强制类型转换的表达式就等价于<code>对象.operator 类型名()</code>，即变成对运算符函数的调用。</p><p>  对类型转化定义过的函数，编译器会在需要时自动调用，例如  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Complex</span>&#123;<br>...<br><span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">double</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> real; &#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>  这个函数就对double()这个强制转换进行了定义, 需要注意的是, <em>对double运算符重载不需要指定返回类型</em>, 因为返回类型就是重载运算符本身代表的类型, 即为double</p><p>  定义之后, 在本该出现 double 类型的变量或常量的地方，如果出现了一个 Complex 类型的对象，那么该对象的 operator double 成员函数就会被调用，然后取其返回值使用。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Complex <span class="hljs-title">c</span><span class="hljs-params">(<span class="hljs-number">1.2</span>, <span class="hljs-number">3.4</span>)</span></span>;<br>cout &lt;&lt; (<span class="hljs-type">double</span>)c &lt;&lt; endl;  <span class="hljs-comment">//输出 1.2</span><br><span class="hljs-type">double</span> n = <span class="hljs-number">2</span> + c;  <span class="hljs-comment">//等价于 double n = 2 + c. operator double()</span><br>cout &lt;&lt; n;  <span class="hljs-comment">//输出 3.2</span><br></code></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="1-C-const相关"><a href="#1-C-const相关" class="headerlink" title="1. C++ const相关"></a>1. C++ const相关</h3><ul><li><p>const成员变量  </p><p>const成员变量非常好定义, 只需要在定义时在最前面加上const关键字即可, 定义为const的变量无法更改其值  </p></li><li><p>const成员函数  </p><p>常成员函数的定义方法为在函数的最后加一个const关键字, 例如:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Student::getage</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>&#123;<br>  <span class="hljs-keyword">return</span> m_age;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个代码中, getage函数加了const关键字, 那么其对所有成员变量的访问权限就变为了只读<br>需要注意的是, 加了const的和不加const的函数是两个完全不同的函数原型。<br>还有需要注意的事是，如果const关键字被加在了一个函数的最开头， 那么就说明该函数的返回值是一个常量， 不允许修改其返回值  </p></li><li><p>常对象<br>  定义常对象的语法和定义常量的语法类似：          </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-keyword">class</span> <span class="hljs-title">object</span><span class="hljs-params">(params)</span></span>;  <br><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-type">const</span> <span class="hljs-title">object</span><span class="hljs-params">(params)</span></span>;  <br><span class="hljs-type">const</span> <span class="hljs-keyword">class</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">class</span>(params);<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">const</span> *p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">class</span>(params);<br></code></pre></td></tr></table></figure><p> class为类名，object为对象名，params为实参列表， p为指针名。两种方式定义出来的对象都是常对象。 </p><p> 一旦将对象定义为常对象之后，不管是哪种形式，该对象就只能访问被 const 修饰的成员了（包括 const 成员变量和 const 成员函数），因为非 const 成员可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。</p></li></ul><h2 id="2-static关键字"><a href="#2-static关键字" class="headerlink" title="2. static关键字"></a>2. static关键字</h2><p>  声明为static的变量会存储在bss段或者data段，而不是在栈中，因此当一个函数的执行周期结束后并不会被释放掉，同时static不会破坏类的封装性，类外不能访问protect和private的变量。</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++逆向工程</title>
    <link href="/2024/02/24/C-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <url>/2024/02/24/C-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="C-逆向工程基础"><a href="#C-逆向工程基础" class="headerlink" title="C++逆向工程基础"></a>C++逆向工程基础</h2><p>在之前的文章中讲过了调用约定相关的知识, 这里就不在赘述, 阅读之前需要重点回顾一下thiscall和cdecl这两个调用约定  </p><h3 id="1-this指针"><a href="#1-this指针" class="headerlink" title="1. this指针"></a>1. this指针</h3><p>所有静态(public的)的c++成员函数都使用this指针, this都被初始化, 指向用于调用成员函数的对象, 例如  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">obj1.<span class="hljs-built_in">func</span>()<br>obj2.<span class="hljs-built_in">func</span>()<br>p_obj-&gt;<span class="hljs-built_in">func</span>()<br></code></pre></td></tr></table></figure><p>上面的三次调用func的过程中, this分别指&amp;obj1, &amp;obj2,  &amp;p_obj  , 微软的thiscall调用约定会将this传递到ECX寄存器中, 而GNU g++的编译器的cdecl调用约定会把this当作成员函数的第一个参数, 一般是最后一个压入栈中的。<br>以菜鸟教程中关于c++多态的实例代码为例： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//code number: 001</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> width, height;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Shape</span>( <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>)<br>    &#123;<br>        width = a;<br>        height = b;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Parent class area :&quot;</span> &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span>: <span class="hljs-keyword">public</span> Shape&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Rectangle</span>( <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>):<span class="hljs-built_in">Shape</span>(a, b) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;Rectangle class area :&quot;</span> &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> (width * height); <br>    &#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Triangle</span>: <span class="hljs-keyword">public</span> Shape&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Triangle</span>( <span class="hljs-type">int</span> a=<span class="hljs-number">0</span>, <span class="hljs-type">int</span> b=<span class="hljs-number">0</span>):<span class="hljs-built_in">Shape</span>(a, b) &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">area</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123; <br>        cout &lt;&lt; <span class="hljs-string">&quot;Triangle class area :&quot;</span> &lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> (width * height / <span class="hljs-number">2</span>); <br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 程序的主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">( )</span></span><br><span class="hljs-function"></span>&#123;<br>    Shape *shape;<br>    <span class="hljs-function">Rectangle <span class="hljs-title">rec</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">7</span>)</span></span>;<br>    <span class="hljs-function">Triangle  <span class="hljs-title">tri</span><span class="hljs-params">(<span class="hljs-number">10</span>,<span class="hljs-number">5</span>)</span></span>;<br><br><span class="hljs-comment">// 存储矩形的地址</span><br>shape = &amp;rec;<br><span class="hljs-comment">// 调用矩形的求面积函数 area</span><br>shape-&gt;<span class="hljs-built_in">area</span>();<br><br><span class="hljs-comment">// 存储三角形的地址</span><br>shape = &amp;tri;<br><span class="hljs-comment">// 调用三角形的求面积函数 area</span><br>shape-&gt;<span class="hljs-built_in">area</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>该代码编译完成之后, 在ida中反编译的结果如下:  </p><p><img src="/images/pasted-36.png" alt="IDA反编译的伪代码">  </p><p>可以看到, 其中圈出来的部分v5 v4分别就是源代码中声明的变量的指针, 在调用成员函数时, 函数的第一项参数都是指向实例化后的对象的指针。 </p><h3 id="2-如何理解多态"><a href="#2-如何理解多态" class="headerlink" title="2. 如何理解多态"></a>2. 如何理解多态</h3><p>在c++中存在多态的概念, 此处还是以code 001为例, 当我们编译code 001时, 会发现其输出为  </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">Parent class area :<br>Parent class area :<br></code></pre></td></tr></table></figure><p>&emsp;这并不是我们期望的输出, 我们的期望输出是:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">Rectangle class area :<br>Triangle class area :<br></code></pre></td></tr></table></figure><p>&emsp;这种情况下, 就需要使用到c++中的多态概念, 即:相同名称行使不同功能。<br>&emsp;那么这种情况是怎么发生的呢？ 这里就需要理解两个概念 <strong>早绑定</strong> 和<strong>延迟绑定</strong>。<br><br>&emsp;首先， 绑定的概念是将符号变更为地址， 那么code 001 在编译时，其就会将里面的函数符号更换为地址，因为shape是一个已经声明过的变量，所以编译器会自动推理其类型， 为后面该变量所调用的成员函数进行绑定，那么此时绑定的函数都是Shape这个类的成员函数，因此所有的area函数都将是Shape这个类中的函数。<br>&emsp;如果为成员函数添加了virtual关键字，那么其就会通过虚表进行延后绑定。</p><h3 id="3-虚函数和虚表"><a href="#3-虚函数和虚表" class="headerlink" title="3. 虚函数和虚表"></a>3. 虚函数和虚表</h3><p>&emsp;虚函数在c++中实现多态。编译器在编译源代码时，编译器会为每一个包含虚函数的类生成一个表，其中包含<strong>指向每一个虚函数的指针</strong>。该表就叫虚表(vtable)。除此之外，编译器会为每一个类添加一个额外的成员变量，成为虚表指针(vtable pointer), 该指针会在适当的时候（一般是在运行创建对象的实例时）指向虚表，并且其是类的第一个成员变量。拿以下程序为例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//code number: 002</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">A</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>=<span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func3</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func4</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    &#125;;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>:<span class="hljs-keyword">public</span> A&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">B</span>();<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func5</span><span class="hljs-params">()</span></span>;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> z;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>&emsp;在上述程序中,B是A的一个子类, B中有5个虚函数(其中func1是A中的函数, 在B中对其进行了重构,并且B中多了一个函数func5, 所以B总共有5个虚函数)同时，A中存在一个纯虚函数，这就说明func1必须这种子类中进行重写，否则无法创建B的实例。<br>&emsp;在上面的程序中，看起来似乎A中存在两个数据成员，B有三个数据成员，实际上A有三个，B有四个， 因为其中包含一个虚表指针，虚表指针是两个类的第一个数据成员， 是编译器添加上去的<br><img src="/images/pasted-35.png" alt="虚表布局"><br>&emsp;像上面的布局，虚表有两个，分别是class A的和class B的，由于B中对func1和func5进行了重写, 所以B的虚表中的func1和func5都是B的函数地址,而其它没有在b中重写的函数则直接引用A的函数地址。<br>由于没有对纯虚函数func1进行实现,所以A的虚表中并没有func1的地址, 此时, 编译器会插入一个处理错误的函数的地址, 名为purecall, 这个函数理论上不会被调用, 其会令程序终止运行。  </p><p><img src="/images/pasted-37.png" alt="示例代码">  </p><p>对于上述代码, 调用了一个名为vfunc3的虚函数, 由于声明时声明的对象是A类型的, 但是实际上对象是B类型的对象, 所以在调用函数vfunc3时应该也要调用B对象的func3, 那么此时编译器就会使用虚表机制。</p><p>首先要将第虚表指针读出（结构体的第一个参数， 即为1处的eax），然后根据edx+8（即为寻址）来找到vfunc3的地址，然后再执行  </p><p>那么根据前面的代码，可以定义以下结构体  </p><p><img src="/images/pasted-38.png" alt="自定义结构体">  </p><p>此时, 再将虚表引用操作重新格式化后就会变成<code>mov eax, [edx+B_vtable.vfunc3]</code>  </p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>逆向工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDA中创建结构体</title>
    <link href="/2024/02/23/IDA%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2024/02/23/IDA%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<h2 id="IDA中的结构体"><a href="#IDA中的结构体" class="headerlink" title="IDA中的结构体"></a>IDA中的结构体</h2><p>在IDA中, 遇见的结构体有以下四种情况:全局变量的结构体(定义在全局的变量), 创建在栈上的结构体(局部变量), 创建在堆上的结构体(使用malloc函数分配空间的指针), 结构体数组。  </p><p>*<br>对于声明在全局的结构体，编译器在编译时可以计算出每个成员的地址，不必进行任何计算， 所以声明在全局的结构题在反编译时看起来与没有声明结构体是一样的，乍一看很像一堆全局变量。  </p><ul><li><p>对于分配在栈上的结构体， 访问其成员变量页不需要任何计算， 编译器可以直接访问到每个字段的相对偏移量， 在这种情况下， 乍一看很像一堆局部变量</p></li><li><p>分配在堆上的结构体，就是先声明一个该结构体的指针， 然后在通过malloc函数为其分配空间，这种东西就没有办法通过在ida中创建结构体来恢复其在程序中应用的符号了，只能通过观察其在栈堆中的分配和操作来理解该结构体  </p></li><li><p>结构体数组唯一要注意的点是分配在堆上的结构体数组，此时malloc的参数可能是结构体大小的某一个倍数，而不是整个结构体的大小</p></li></ul><h2 id="创建IDA结构体"><a href="#创建IDA结构体" class="headerlink" title="创建IDA结构体"></a>创建IDA结构体</h2><p>在view -&gt; open subviews -&gt; structures中可以打开结构体窗口, 其中标蓝的是ida找到的结构体, 下图中框起来的是IDA告诉你,你可以执行的操作的快捷键。    </p><p><img src="/images/pasted-31.png" alt="IDA中的结体窗口"></p><p>同样，在view -&gt; open subviews -&gt; local types中就可以打开已经存在的变量类型， 如果你在suructers窗口中创建了结构体，那么就可以在本窗口中找到。选中需要编辑的变量类型， 按右键-&gt; edit(快捷键ctrl + E)就可以在本窗口中按照c语言风格来声明结构体中的成员变量了。  </p><p><img src="/images/pasted-32.png" alt="编辑结构体"></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go设计方法</title>
    <link href="/2024/02/23/Go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/02/23/Go%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="继承和重载"><a href="#继承和重载" class="headerlink" title="继承和重载"></a>继承和重载</h2><p>在Go中, 继承可以使用匿名字段的方式实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>    id   <span class="hljs-type">int</span><br>    name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Manager <span class="hljs-keyword">struct</span> &#123;<br>    User<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="函数选项模式"><a href="#函数选项模式" class="headerlink" title="函数选项模式"></a>函数选项模式</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IDA中的数组</title>
    <link href="/2024/02/23/IDA%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/"/>
    <url>/2024/02/23/IDA%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="在IDA中的数据类型"><a href="#在IDA中的数据类型" class="headerlink" title="在IDA中的数据类型"></a>在IDA中的数据类型</h2><p>数组是最简单的复合数据结构, 传统意义的数组是包含同一数据类型的连续元素组成的内存块, 也就是说, 数组实际上就是一段内存块的集合。 </p><p>而在c语言中，我们都熟知的一个东西就是数据类型， 而在计算机底层的概念中，数据类型是一个抽象的概念， 其本质是对一段内存布局中读写数据的长度。  </p><p>举例来说， 对于c语言中的int类型，其在x86中的长度是四个字节，也就是说计算机如果想读取一个int类型的数据，就要连续的读取四个字节才能正确的表示一个int类型的数  </p><p><img src="/images/pasted-24.png" alt="内存中存储一个int变量">  </p><p>如图所示, 如果在c语言中声明 <em>int a&#x3D;1</em>, 那么在程序编译完成后就会按照上图的形式存储。  </p><p>显然，ida并没有正确识别出其数据类型，这是因为编译器剥离了符号，但是经验丰富的逆向工程师是能够识别出这个变量实际上是一个32位整数。  </p><p>因此，逆向工程师会选择选中该数据，按快捷键d来改变其数据类型，对于那些更加了解ida的逆向工程师来说，他们可能更加乐意在option -&gt; set up datatypes(快捷键Alt + D) 中更改数据类型。</p><h2 id="在IDA中创建数组"><a href="#在IDA中创建数组" class="headerlink" title="在IDA中创建数组"></a>在IDA中创建数组</h2><p>在IDA中，你可以在Edit -&gt; Array中创建数组。在IDA中创建数组的默认大小是根据创建数组的第一个元素的长度决定的，例如创建数组的第一个元素的长度是4字节，那么之后所有的元素长度都是4字节，所以更改好第一个元素的长度很重要，其次就是要填好Array Size，这个代表数组的长度是多少，有几个元素这里就填几  </p><p><img src="/images/pasted-25.png" alt="IDA创建数组对话框">  </p><p>其中有几个选项这里简单介绍一下  </p><ul><li><p>Array Size: 创建数组的长度  </p></li><li><p>Item on a line: 一行显示的数组的长度</p></li><li><p>Element print width: 打印数组时的宽度, 这里指的是显示的宽度, 指定宽度后数据将在指定范围内显示  </p></li><li><p>use “dup” construct: 是否使用dup将重复的数据折叠  </p></li><li><p>signed element : 是否使用有符号元素  </p></li><li><p>display index： 该选项会在伪代码窗口中将元素按照数组的形式显示</p></li></ul><p>这里创建数组时需要自己对反编译的结果进行识别, <strong>gcc编译器在编译时, 如果一个数组并没有过用变量访问数组中的元素时（例如a[i]这种访问方式，只用过a[1]这种常量当访问下标）, 编译器就会对其进行优化, 使得ida无法正确识别出这一串数据是一个数组, 所以需要自己创建数组</strong>, 例如以下程序:  </p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">int a<span class="hljs-comment">[17]</span>=&#123;1,2,3,4&#125;;<br>int main()&#123;<br>a<span class="hljs-comment">[0]</span>+=11;<br>a<span class="hljs-comment">[2]</span>+=12;<br>a<span class="hljs-comment">[17]</span>=18;<br>a<span class="hljs-comment">[16]</span>=20;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该程序在编译完成并剥离符号表后, 会变成下面这个样子  </p><p><img src="/images/pasted-27.png" alt="IDA伪代码视图"></p><p><img src="/images/pasted-28.png" alt="IDA反汇编视图"></p><p>这里选中第一个元素,将其转化位dd(第二个d是double word的意思), 计算下数组长度(源代码中是a[17], 这里数组长度就填18), 然后创建数组, 就可以生成一个数组了。</p><p>可以看到, 在反汇编窗口中并不能直观的看出这段数据是一个数组, 并且还多了一些东西, 初步估计是编辑器为了防止内存溢出设置的缓冲区域  </p><p><img src="/images/pasted-29.png" alt="编译完成后,数组前后会多出20h个字节的区域"></p><p><img src="/images/pasted-30.png" alt="成功创建数组后的ida中伪代码视图"></p><p>至此, 就成功创建了一个数组, 后面再进行逆向分析都会容易很多。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔记: IDA使用</title>
    <link href="/2024/02/20/%E6%89%8B%E5%86%8C-IDA%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/02/20/%E6%89%8B%E5%86%8C-IDA%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>文本搜索: Search -&gt; Text(Alt + T)启动文本搜索，可以用于搜索一个完整的词，按ctfl + T就可以重复前一项搜索，匹配下一项结果。  </p><p>二进制搜索： serach -&gt; squence of bytes(ALT + B)即可启动二进制搜索。其可以搜索一个二进制字节序列，以空格分隔，按ctfl + T就可以重复前一项搜索，匹配下一项结果。如果想要搜索内嵌字符串（即十六进制种ASCII字符串），则需要讲搜索字符串用引号括起来 。如果想要搜索操作码序列而不是ASCII文本时，记得勾选Case sensitive，不然会出现匹配到无关结果。</p><p>函数: 从Edit -&gt; function 中即可进行创建函数, 删除函数等操作, 按快捷键c可以将一段十六机制数识别为代码</p><p>数组: 在Edit -&gt; Array中打开创建数组对话框, 如果指定位置的第一个数据项已经被定义, 那么直接按右键,在弹出的上下文菜单中就会显示Array选项, 创建的数组的元素的类型由第一个元素的类型决定  </p><h2 id="ida显示设置"><a href="#ida显示设置" class="headerlink" title="ida显示设置:##"></a>ida显示设置:##</h2><ul><li><p>栈指针: general -&gt; option -&gt;disassembly-&gt;勾选stack pointer 即可在ida中显示函数中的栈指针的相对值<br><img src="/images/pasted-21.png" alt="栈指针开启后的效果">  </p></li><li><p>一行中显示字节码的数量<br><img src="/images/pasted-22.png" alt="选择一行中可显示的字节码数量"> </p></li><li><p>更改数据类型<br>options -&gt; setup data types  中打开对话框<br><img src="/images/pasted-23.png" alt="指定数据大小"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈帧</title>
    <link href="/2024/02/20/%E6%A0%88%E5%B8%A7/"/>
    <url>/2024/02/20/%E6%A0%88%E5%B8%A7/</url>
    
    <content type="html"><![CDATA[<p>以下面的程序为例  </p><p><img src="/images/pasted-16.png" alt="示例函数"></p><p>demo_stackframe函数调用了一个bar函数, 并且demo_stackframe函数自身还包含三个参数和几个局部变量, 那么在调用demo_stackframe函数时就会产生一个栈帧, 该栈帧长下面这个样子  </p><p><img src="/images/pasted-17.png" alt="基于ESP的栈帧">  </p><p>这个是基于ESP的栈帧, 它包含了abc三个参数(在调用demo_stackframe时产生的), 一个eip,(用于确定demo_stackframe返回时的地址)四个局部变量。那么对于该栈帧来说， 想要调用其中一个局部变量就可以使用偏移的方式来调用，例如[esp+4]就代表调用y这个变量 ，但是基于ESP的栈帧有个坏处， 那就是在demo_stackframe中调用函数bar的时候， 会用到push来将bar函数需要用到的函数压入栈中，而push又会改变esp的位置， 所以会产生一些混乱的情况 ，例如：</p><p><img src="/images/pasted-18.png" alt="示例代码">  </p><p>上面的1 和 2 处虽然都是esp+4，但是却代表不同参数，所以说不是很好看，为了解决这个问题， x86提供了一个名为EBP的寄存器专门用来存栈帧指针， 啥意思呢？  </p><p>简单来说， EBP这个寄存器中存储的是进入到被调用函数时，ESP的位置。</p><p><img src="/images/pasted-19.png" alt="基于EBP的栈帧">  </p><p>像上面这个图， 相较于基于ESP的栈帧多了一个saved ebp， 这个是因为stdcall和cdecl都要求函数只能动EAX，ECX和EDX，别的寄存器都不能动，（因此其它寄存器都被称为被保护寄存器）<br>所以要想使用EBX，就必须先把EBX的值存下来，然后在用完EBX之后再把值存回去</p><p>在使用基于EBP的栈帧时，调用者需要执行以下代码  </p><p><img src="/images/pasted-20.png" alt="示例代码">  </p><p>也就是说，EBP指向的其实就是自己原先的值的位置，而在EBP之下的东西（栈是向下生长的）都是局部变量，或者是其它被调用函数的东西，我们不是很关心， 我们只需要知道， 在本函数执行完毕时，直接将ESP放到EBP的位置上就可以释放所有局部变量， 并且基于EBP的栈帧的所有变量的偏移值都是不会变的。</p><p>执行完demo_stackframe毕之后， 只需要 </p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>, <span class="hljs-built_in">ebp</span><span class="hljs-comment">;直接清除掉了所有局部变量</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span> <span class="hljs-comment">;恢复ebp最开始的值</span><br><span class="hljs-keyword">ret</span>     <span class="hljs-comment">;回到调用demo_stackframe的那个call语句的下面那一条语句, 等价于弹出栈中的saved eip, 然后跳转到eip的位置</span><br></code></pre></td></tr></table></figure><p>当然, 上述指令被x86简化了, 其提供了一个leave指令 </p><pre><code class="hljs">leaveret</code></pre><p>leave指令执行将esp释放到栈帧最开始的位置(也就是ebp指的位置),以达到清除全部临时变量的效果, 然后再恢复ebp最开始的值。  </p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>深入理解计算机系统</tag>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>调用约定</title>
    <link href="/2024/02/20/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/"/>
    <url>/2024/02/20/%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>调用约定是指程序在调用函数时的规则，例如参数入栈的顺序，返回值的位置等。  </p><h2 id="C调用约定（-cdecl）"><a href="#C调用约定（-cdecl）" class="headerlink" title="C调用约定（_cdecl）"></a>C调用约定（_cdecl）</h2><p>_cdecl是x86体系中c编译器使用的默认调用约定，其要求函数参数按照从右往左的顺序入栈， 这样就能使第一个参数永远放在栈顶  </p><p> 同时，该约定还要求函数的参数如果放在了栈中， 那么就需要由调用者（caller）函数将参数压栈，并且在返回时将栈指针恢复（即恢复esp的位置）  </p><p>例如：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-number">4</span><br><span class="hljs-keyword">push</span> <span class="hljs-number">3</span><br><span class="hljs-keyword">push</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">push</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">call</span> func<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>,<span class="hljs-number">16</span><br><br></code></pre></td></tr></table></figure><p>当然也有不改变esp的情况， 例如  </p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">12</span>],<span class="hljs-number">4</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">8</span>],<span class="hljs-number">3</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span>+<span class="hljs-number">4</span>],<span class="hljs-number">2</span><br><span class="hljs-keyword">mov</span> [<span class="hljs-built_in">esp</span>],<span class="hljs-number">1</span><br><span class="hljs-keyword">call</span> func<br><br></code></pre></td></tr></table></figure><p>像上面的函数没有改变esp的位置, 所以不需要再次调整esp, 可以直接执行下一条指令  </p><h2 id="标准调用约定-stdcall"><a href="#标准调用约定-stdcall" class="headerlink" title="标准调用约定(_stdcall)"></a>标准调用约定(_stdcall)</h2><p>该约定为微软定义, 其参数的入栈顺序也为从右到左, 但是该约定在函数结束执行时, 由被调用者(callee)函数删除栈中的参数。这种方式相对于cdecl来说， 被调用者函数如果接受的是一个变长参数， 那么被调用函数就不知道自己接受的参数到底有多长，所以stdcall不支持变长参数的函数（例如printf）</p><p>x86编译器会使用ret指令的一种特殊形式来实现上述过程， 即为 <strong>ret [imm]</strong> (imm为一个立即数) 该指令在返回时（回到调用本函数的call指令下面一条指令）时会顺便给栈指针加上这个立即数， 即为从栈中释放imm个字节的空间</p><p>书上说这种调用约定的优点是不需要通过代码从栈中清除参数， 因此该调用约定会稍微快一些（实际上我感觉作用微乎其微， 除非能够在硬件层面上ret imm这种指令要比add这个指令快）  </p><h2 id="x86-fastcall约定"><a href="#x86-fastcall约定" class="headerlink" title="x86 fastcall约定"></a>x86 fastcall约定</h2><p>fastcall是stdcall的一个变体， 它的意思是向寄存器传参，而不是向栈传参，当然学过计算机系统的小伙伴会知道， 程序一般是不把参数放在栈里的， 大多数函数都是将参数放在寄存器中， 只有参数大于七个的时候程序才会考虑优化， 将参数放在栈中。</p><p>而本约定与上述情况类似， 但是fastcall约定函数向寄存器最多传递两个参数， 并且将前两个参数分别放在ECX和EDX寄存器中， 而其他的参数则更stdcall一样， 将参数从右到左压入栈中，并且由被调用者清除参数。</p><h2 id="C-调用约定"><a href="#C-调用约定" class="headerlink" title="C++调用约定"></a>C++调用约定</h2><p>C++有类这么个东西， 它会需要用到this指针（this指向实例化过后的对象）， 如果一个类中包含一个成员函数，并且该函数为非静态成员函数（public的），那么实例化过后的对象在调用这个函数时， this指针就应该指向这个实例化过后的对象， 并且这个this指针需要由调用方提供给被调用方（因为被调用的函数并不知道何时会出现该类的实例化对象）  </p><p>所以如何传递this指针就成为一个问题， C++标准并未规定如何传递this， 所以不太编译器传递this的方式不同</p><p>msC++提供一个 <strong>thiscall</strong>约定，它讲this指针传递到ECX中， 并且由被调用函数清除栈中参数。  </p><p>GNU g++ 将this看成所有非静态成员函数的第一个隐含参数， 其它方面与cdecl相同 ， 因此， 对使用g++编译的代码来说， this永远是放在栈顶的， 并且由调用者删除栈中参数  </p><p>其它调用约定还有很多， 此处不再赘述。</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>深入理解计算机系统</tag>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验：RC4算法</title>
    <link href="/2024/02/18/%E5%AE%9E%E9%AA%8C%EF%BC%9ARC4%E7%AE%97%E6%B3%95/"/>
    <url>/2024/02/18/%E5%AE%9E%E9%AA%8C%EF%BC%9ARC4%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="RC4算法原理"><a href="#RC4算法原理" class="headerlink" title="RC4算法原理"></a>RC4算法原理</h2><p>RC4算法的加密部分就是单纯的将一个密钥流与明文逐字节的进行一次异或，其真正关键的地方在于如何生成密钥流  </p><p>在生成密钥流的时候用到了两个算法， 分别是key-scheduleing algorithm（KSA）算法和pseudo-random generation algorithm（PRGA），而这两个算法则是RC4的核心 , 接下来将以长度为256的明文为例子</p><hr><h2 id="KSA"><a href="#KSA" class="headerlink" title="KSA"></a>KSA</h2><p>ksa首先会初始化一个S盒， 初始化的过程非常的简单， 只需要将S盒按照1-256依次赋值即可  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">255</span>;i++)&#123;<br>S[i]=i;<br>&#125;  <br>   <br></code></pre></td></tr></table></figure><p>然后，建立一个临时数组， 称为T盒，大小与S盒相同，用原始密钥对T进行循环填充</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">255</span>;i++)&#123;<br>           T[i]=K[i % keylen];<br>&#125;  <br>   <br></code></pre></td></tr></table></figure><p>此时，初始化工作已经完成，接下来将进行置换操作  ，对S盒中的元素的位置进行如下交换操作  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">256</span>; i++)<br>&#123;<br>   j = (j + S[i] + T[i]) % <span class="hljs-number">256</span>;<br>    <span class="hljs-built_in">swap</span>(S[i], S[j]);<br>&#125;<br>   <br></code></pre></td></tr></table></figure><hr><h2 id="PRGA"><a href="#PRGA" class="headerlink" title="PRGA"></a>PRGA</h2><p>建立S盒之后，S盒仍然是会发生变化的， 在PRGA中每生成一个字节的密钥流， 就会打乱一次S盒  ,具体步骤如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,j = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化i，j为0</span><br><span class="hljs-type">int</span> cnt=<span class="hljs-number">256</span>;<br><span class="hljs-type">int</span> key[<span class="hljs-number">256</span>];<br><span class="hljs-keyword">while</span>(cnt--)<br>&#123;<br>    <span class="hljs-comment">//i自增1</span><br>    i = (i + <span class="hljs-number">1</span>) % <span class="hljs-number">256</span>;<br>    <span class="hljs-comment">//j自增S[i]</span><br>    j = (j + S[i]) % <span class="hljs-number">256</span>;<br>    <span class="hljs-comment">//交换，打乱S表</span><br>    <span class="hljs-built_in">swap</span>(S[i], S[j]);<br>    <span class="hljs-comment">//使用变量t保存输出S表的下标</span><br>    t = (S[i] + S[j]) % <span class="hljs-number">256</span>;<br>    <span class="hljs-comment">//存储一字节的密钥流序列k</span><br>    key[i]=S[t];<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总的来说,RC4还是一个相当简单的算法的, 其核心思想为生成密钥流,只要能找到对应生成密钥流的逻辑就能轻松的解出题目,<br>只要知道RC4中KSA盒PRGA算法的细节,再找到初始密钥k, 就能自己生成一个密钥流, 对密文进行解密</p><p>最后给出一份实验代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> char unsigned char <span class="hljs-comment">//这里记得使用无符号的char, 否则在置换密钥流的时候会出现段错误(访问负数下标)</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br>string dat=<span class="hljs-string">&quot;welcome to join the SUDA Security and the ATS-Team!!!&quot;</span>;<span class="hljs-comment">//length=53</span><br><span class="hljs-type">int</span> dataLen=<span class="hljs-number">53</span>;<br>string key=<span class="hljs-string">&quot;Sud@s3curi3ty&quot;</span>;<br><span class="hljs-type">int</span> keylength=<span class="hljs-number">13</span>;<br><span class="hljs-type">char</span> S[<span class="hljs-number">256</span>],T[<span class="hljs-number">256</span>];<br><span class="hljs-type">char</span> keyStream[<span class="hljs-number">256</span>];<br><span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">256</span>;i++)&#123;<br>S[i]=i;<br>T[i]=key[i%keylength];<br>&#125;<br><br>j=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">256</span>;i++)&#123;<br>j=(j+S[i]+T[i])% <span class="hljs-number">256</span>;<br><span class="hljs-built_in">swap</span>(S[i],S[j]);<br>&#125;<br><br>j=<span class="hljs-number">0</span>;<br>i=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> tmp=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;cnt&lt;dataLen;cnt++)&#123;<br><br>i=(i+<span class="hljs-number">1</span>)%<span class="hljs-number">256</span>;<br>j=(j+S[i])%<span class="hljs-number">256</span>;<br><br><span class="hljs-built_in">swap</span>(S[i],S[j]);<br>tmp=(S[i]+S[j])%<span class="hljs-number">256</span>;<br>keyStream[cnt]=S[tmp];<br><br><br>&#125;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;dataLen;i++)&#123;<br><span class="hljs-type">int</span> a=(<span class="hljs-type">int</span>)(dat[i]);<br><span class="hljs-type">int</span> b=(<span class="hljs-type">int</span>)(keyStream[i]);<br><br>cout&lt;&lt;(a^b)&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;<br>&#125;<br><br><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>密码学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于逆向中遇到的变量大小的问题</title>
    <link href="/2024/02/13/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%9F%90%E4%BA%9B%E8%BF%9B%E5%88%B6%E9%97%AE%E9%A2%98/"/>
    <url>/2024/02/13/%E5%85%B3%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E6%9F%90%E4%BA%9B%E8%BF%9B%E5%88%B6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>首先, 计算机中最基本的单位是bit, 一个bit只有0或者1两种状态  </p><p>而在做逆向的过程中最基本的单位是一个byte, 也就是两个十六进制数, 一个byte最大可以表示的整数为255(也就是FF)。 有些同学会发现， ASCII码表的长度刚好也是256， 其刚好是一个byte可表示的全部范围。</p><p>在x86架构中，偏移量一般都是用十六进制表示的，并且每一个数字对应的就是一个byte， 例如： [rsp+0h] 和 [rsp+4h]</p><p><img src="/images/pasted-11.png" alt="upload successful"></p><p> 这两个都是表示一个取值， 分别对应rsp+4h和rsp+0h位置的值。 而在观察后发现， 这两个变量存储的空间上刚好差了4h， 这里4h代表的就是4 byte， 也就是说， 这两个变量如果类型相同的话， 可以推断出两个变量的长度就为4 byte。 </p><p>而在之前的博文中提到过，x86架构下规定word的长度为2 byte是定死不变的， 所以这里4 byte刚好就是DWORD， 也就是一个整形的长度 ， 即为一个32 bit的数， 对应的就是8位十六进制数（其最大表示为FFFF FFFF） ，此处ida已经帮我们标注好了，该变量是一个无符号整形。</p><p>再通过观察可以发现这两个变量其实是相邻的，那么假如此时有一个调用为v4[1] , 那么这个语句就代表以v4的长度，取其相邻的下一个数。意思就是v4是一个DWORD， 那么v4[1]就是在v4的地址上再加4个byte ，（因为DWORD的长度是4byte），那么v4[1]代表的其实就是v5这个变量。  </p><p>在做逆向的过程中，有些时候还会遇到结构体的问题， 在修复结构体时也要灵活识别每个成员变量的长度， 推断其属于哪种类型，这里简单给出一些类型对应的长度:  </p><table><thead><tr><th>类型</th><th>二进制长度</th><th>十六进制长度</th><th>十六进制最大表示数</th></tr></thead><tbody><tr><td>char</td><td>8位</td><td>2位</td><td>FF</td></tr><tr><td>int、unsigned int、DWORD</td><td>32位</td><td>8位</td><td>FFFF FFFF</td></tr><tr><td>指针（32位程序）</td><td>32位</td><td>4位</td><td>FFFF FFFF</td></tr><tr><td>指针（64位程序）</td><td>64位</td><td>16位</td><td>FFFF FFFF FFFF FFFF</td></tr><tr><td>long long、 QWORD</td><td>64位</td><td>16位</td><td>FFFF FFFF FFFF FFFF</td></tr></tbody></table><p>这里给出的十六进制最大表示数的意义是如下：</p><p><img src="/images/pasted-15.png" alt="upload successful">  </p><p>方便大家用计算器测试， 因为只有用最大表示数才能直观的看出某一个长度的变量到底是多少位</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>深入理解计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实验: 从应用程序中加载和链接共享库</title>
    <link href="/2024/02/09/%E5%AE%9E%E9%AA%8C-%E4%BB%8E%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93/"/>
    <url>/2024/02/09/%E5%AE%9E%E9%AA%8C-%E4%BB%8E%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%8A%A0%E8%BD%BD%E5%92%8C%E9%93%BE%E6%8E%A5%E5%85%B1%E4%BA%AB%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p><strong>本实验使用linux系统中自带的库函数实现在程序中加载共享库</strong></p><p>一般在程序中不会依赖这种方法实现共享库的加载, 更多的情况是在编译阶段通过引入头文件的方式, 直接将需要引入的符号直接在编译阶段引入, 而本实验实现通过一个文件路径和符号名称实现在任意一个程序中加载共享库  </p><p>本实验将会使用到的函数如下:  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br>   <span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">dlopen</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename, <span class="hljs-type">int</span> flag)</span></span>;<br>   <span class="hljs-comment">// 若成功返回指向句柄的指针,否则返回NULL, filename为一个路径, flag为可选项, 一般使用RTLD_LAZY即可</span><br>   <br>   <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dlsym</span><span class="hljs-params">(<span class="hljs-type">void</span> *handle , <span class="hljs-type">char</span> *symbol)</span></span>; <br>   <span class="hljs-comment">//若成功则返回指向符号的指针, 否则返回NULL, handle为已经打开的共享库的句柄, symbol为要使用的符号</span><br>   <br>   <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dlclose</span><span class="hljs-params">(<span class="hljs-type">void</span> *handle)</span></span>;<br>   <span class="hljs-comment">// 成功返回0 出错返回-1;</span><br>   <br>   <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">dlerror</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br>   <span class="hljs-comment">//如果有调用失败的情况则返回出错信息,否则返回NULL  </span><br>   <br></code></pre></td></tr></table></figure><p>首先对以下程序进行编译</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><span class="hljs-type">int</span> addcnt;<br>    <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addvec</span><span class="hljs-params">(<span class="hljs-type">int</span> *x, <span class="hljs-type">int</span> *y, <span class="hljs-type">int</span> *z,<span class="hljs-type">int</span> n)</span></span>&#123;<br>        <span class="hljs-type">int</span> i;<br>        addcnt++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>                z[i]=x[i]+y[i];<br><br>&#125;<br>    <br></code></pre></td></tr></table></figure><p>  使用如下指令编译共享库文件:  </p><pre><code class="hljs">  ❯ gcc -share -fpic addvec.c -o libvector.so  </code></pre><p>   -share选项将会使用动态库, -fpic参数是告诉编辑器产生于位置无关的代码(Position-Independent Code)  </p><p>   然后将libvector.so移动到同目录下名为lib的文件夹下, 此处是为了体现dlopen函数中的filename参数是文件路径</p><p>在mian.c中写如下代码  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><br><br><span class="hljs-type">int</span> x[<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br><span class="hljs-type">int</span> y[<span class="hljs-number">2</span>]=&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> z[<span class="hljs-number">2</span>];<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><br><br>       <span class="hljs-type">void</span> *handle;<br>       <span class="hljs-built_in">void</span>(*addvec)(<span class="hljs-type">int</span>*,<span class="hljs-type">int</span>*,<span class="hljs-type">int</span> * ,<span class="hljs-type">int</span>  );<br>       <span class="hljs-type">char</span> *error;<br><br>       handle = <span class="hljs-built_in">dlopen</span>(<span class="hljs-string">&quot;./lib/libvector.so&quot;</span>,RTLD_LAZY);<br><br>       <span class="hljs-keyword">if</span>(!handle)&#123;<br>               <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;%s\n&quot;</span>,<span class="hljs-built_in">dlerror</span>());<br>               <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>       &#125;<br><br><br>       addvec = <span class="hljs-built_in">dlsym</span>(handle , <span class="hljs-string">&quot;addvec&quot;</span>);<br><br>       <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dlerror</span>()!=<span class="hljs-literal">NULL</span>)&#123;<br>               <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;failed&quot;</span>);<br>               <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>       &#125;<br><br><br>       <span class="hljs-built_in">addvec</span>(x,y,z,<span class="hljs-number">2</span>);<br><br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;z=[%d,%d]\n&quot;</span>,z[<span class="hljs-number">0</span>],z[<span class="hljs-number">1</span>]);<br><br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;execute successfully\n&quot;</span>);<br><br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>然后就可以编译main.c了</p><pre><code class="hljs">❯ gcc main.c   </code></pre><p> 此时在同名目录下就会生成一个a.out 是一个可执行文件, 可以正常运行了  </p><pre><code class="hljs"> ❯ ./a.outz=[4,6]execute successfully</code></pre>]]></content>
    
    
    <categories>
      
      <category>实验</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深入理解计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是动态库</title>
    <link href="/2024/02/08/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E5%BA%93/"/>
    <url>/2024/02/08/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>动态库的全称是_”动态链接共享库”_  , 其是一个目标模块, 在运行和加载时可以加载到任意的内存地址, 并和一个在内存中的程序链接起来, 这个过程叫做 <em>动态链接(dynamic linking)</em>  , 其是由一个叫做 <em>动态链接器(dynamic linker)</em> 的程序来执行的。</p><p>在linux中动态库通常被叫做共享目标（shared object） 用.so作为后缀, 而在windows中叫做动态链接库, 用.dll做后缀  </p><p>动态链接库的工作原理如下:  </p><p><img src="/images/pasted-9.png" alt="动态链接库工作流程">  </p><p><em>此处的图片出自《深入理解计算机系统》，main2.c在本文中命名为main.c, prog21在本文中命名为prog</em></p><p>首先, 先由翻译器将main.c中的代码(以及其引入的头文件) 编译成obj文件, 其次再由链接器将so文件和obj文件链接起来, 在执行时, 加载器会根据链接时指定的<br>地址来加载so文件中的代码段 ,这个过程由动态链接器完成, 下面给出实验过程  </p><p><em>注意: 此时使用的代码与上一章””什么是静态库”中展示的代码相同</em>  </p><p>使用如下命令生成libvector.so文件</p><pre><code class="hljs">❯ gcc -shared -fpic -o libvector.so addvec.c multvec.c</code></pre><p>-shared选项代表生成一个共享目标文件(也叫动态库) , -fpic代表生成与位置无关的代码  (编译共享库时总是需要开启此选项)</p><p>随后, 将动态库链接到主程序中  </p><pre><code class="hljs">❯ gcc -o prog main.c ./libvector.so</code></pre><p>然后就成功生成了名为prog的可执行文件</p><p>动态链接器(ld-linux.so)的工作原理如下:  </p><ul><li>重定位libc.so的文本和数据到某个内存段  </li><li>重定位libvector.so</li><li>重定位porg中所有对libc.so和libvector.so定义的符号的引用</li></ul><p>最后动态链接器再将控制传递给应用</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深入理解计算机系统</tag>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是静态库</title>
    <link href="/2024/02/08/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E5%BA%93/"/>
    <url>/2024/02/08/%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>静态库(static library)是编译系统的一种机制, 用以解决如下问题:  </p><ul><li>编译器如何向用户提供一些标准函数</li></ul><p>一种方式是将标准函数全部放到一个目标文件(object file)中, 但是这么做就需要用户每次编译时采用  </p><pre><code class="hljs">linux&gt; gcc main.c /usr/lib/libc.o   </code></pre><p>这种方法对程序员有适当的便利, 但是缺点是每次编译时都需要把整个目标文件全部拷贝到可执行文件中去, 会增大文件的体积  </p><p>其次, 对于标准函数的改变将会需要重新编译整个源文件, 费时费力。  </p><p>所以，静态库的概念被提出来，以解决上述问题。   </p><p>在静态库中， 不同的函数被放在不同的模块中，在连接时，连接器只复制被引用的目标模块，这样就减少了程序的占用空间。  </p><p>下面给出构造静态库和使用静态库的实验  </p><p><img src="/images/pasted-6.png" alt="addvec.c"></p><p><img src="/images/pasted-7.png" alt="mulvec.c"></p><p>使用如下指令编译  </p><pre><code class="hljs">❯ gcc -c addvec.c multvec.c</code></pre><p>这里的-c指令是在链接阶段停止, 只做预处理, 编译 ,汇编, 这会将程序编译成一个obj文件,在同目录下生成同名的.o文件   </p><p>编译好之后运行  </p><pre><code class="hljs">linux&gt; ar rcs libvector.a addvec.o mulvec.o  </code></pre><p>就可以生成一个名为libvector.a的静态链接库文件(a的意思是archive)</p><p>为了调用生成的库文件, 编写如下源程序<br><img src="/images/pasted-8.png" alt="upload successful"></p><p>然后在编译可执行文件时, 使用如下指令  </p><pre><code class="hljs">linux&gt; gcc -c main.c</code></pre><p>这个指令先生成一个关于main的目标文件, 但是此时并不进行连接, 也就是说无法执行</p><p>然后再执行以下指令</p><pre><code class="hljs">linux&gt; gcc -static -o prog main.o ./libevector.a</code></pre><p>-static参数告诉编译器, 连接器应该构建一个完全链接的可执行文件, 它可以直接加载到内存并运行, 此选项会禁用动态库, 也就是说会把动态库中的所有东西都编译出来, 一般编译出来的东西都很大</p><pre><code class="hljs">p.s:在linux环境下, 链接库文件的后缀为.a, 在windows平台下后缀通常为.lib </code></pre><p>总得来说, 先将自己写好的代码(addvec.c和multvec.c)编译为obj文件, 然后通过ar工具将可重定位文件链接为一个.a文件(静态链接库文件)  </p><p>在这里还涉及到一个隐式函数的问题, 在c语言中, 如果一个函数在引用时没有声明, 那么在编辑器使用它的时候会自动为其添加隐式声明, 在链接时寻找其符号</p><p>紧接着, main.c源文件在通过翻译器(cpp,ccl,as)的作用下, 生成一个main.o(可重定位目标文件), 然后再与libvector.a(我们自己构建的静态链接库), libc.a(GNU提供的标准库文件)链接, 生成一个完全链接的可执行目标文件  </p><p>在此过程中, 链接器不会使用multvec.o中的内容 , 因为程序没有引用multvec.o中的符号  </p><p>在使用静态链接库时, 一般需要把他们放在命令行的结尾, 并且根据依赖关系进行排序, 否则就可能会发生”undefined reference”的错误, 这种错误的发生与编辑器实现链接时的规则有关, 但是近代的gcc有没有改善这一问题暂时还不清楚, 有可能以后不会再遇到这种问题也说不定，这块的内容还没有做过实验</p><p>对于上述问题的解决方法, 可以用ar工具将多个.a文件再次合并为一个单独的.a文件</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深入理解计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>符号和符号表</title>
    <link href="/2024/02/07/%E7%AC%A6%E5%8F%B7%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A1%A8/"/>
    <url>/2024/02/07/%E7%AC%A6%E5%8F%B7%E5%92%8C%E7%AC%A6%E5%8F%B7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<p>首先先讲一个知识: 在c语言中的static的作用为使符号成为模块内部的私有符号, 类似于c++和java中的private, 加了static的变量或函数则不可在外部模块中被访问。<br>而在后续的描述中，统一把单个执行某一种功能的c语言源文件称为“模块”</p><p>在符号表中有以下三种变量：  </p><ul><li>全局连接器符号（由本模块定义的并且能被其他模块引用的全局符号）， 对应非静态函数和全局变量  </li><li>外部符号（由其他模块定义并被本模块应用的全局符号）</li><li>局部符号（只被本模块定义和应用的符号）</li></ul><p>在.symtab段中的符号表不包括本地非静态变量的任何符号(局部变量), 因为他们是被存放在栈中的。  </p><p>但是如果局部变量被加了static属性，那么该变量会在.data段和.bss段中被分配一个空间, 并且在.symtab段中有唯一名字的本地连接器符号</p><p>符号表的条目定义如下, 使用readelf即可读到一个目标文件中的符号表</p><p><img src="/images/pasted-5.png" alt="upload successful"></p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>深入理解计算机系统</tag>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ELF文件格式简述</title>
    <link href="/2024/02/06/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"/>
    <url>/2024/02/06/ELF%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="计算机编译可执行文件时的步骤"><a href="#计算机编译可执行文件时的步骤" class="headerlink" title="计算机编译可执行文件时的步骤"></a>计算机编译可执行文件时的步骤</h3><p> 在计算机编译可执行文件时主要分为以下几个步骤:  </p><ol><li>对于一个或多个(在定义实现的情况下是多个源文件)c语言编写的ascii源文件,先由预处理器将头文件,宏定义等内容替换, 形成一个ascii码的中间文件: <strong>.i文件</strong>, 此时文本和编写的源代码差别不是很大  </li><li>编译器(ccl)将.i文件翻译成一个ascii的汇编语言文件: <strong>.s文件</strong> ,里面是可读的汇编指令</li><li>汇编器(as)将.s文件翻译成一个或多个可重定位目标文件<br>  <strong>(relocatable object file)</strong> : <strong>.o文件</strong> , 此时以及将ascii文件编译为hex文件, 其文件格式符合elf文件格式  </li><li>连接器(ld)将各个可重定位目标文件(后面简称obj文件)和一些必要的系统目录组合, 创建一个可执行目标文件 <strong>(executable object file )</strong></li></ol><p>此时, 一个程序就被编译好了, 在shell中直接输入文件名即可运行, shell在加载的过程中会使用一个名为loader的函数, 它将可执行文件中的代码数据复制到内存, 然后将控制权转移到函数的开头 </p><p>对于目标文件(object file) 有三种形式, 分别是</p><ul><li><strong>可重定位目标文件(relocatable object file )</strong>: 可以在编译时于其他obj文件合并</li><li><strong>可执行目标文件(executable object file)</strong>:  可直接被复制到内存并执行</li><li><strong>共享目标文件(shared  object file)</strong>:  lib或者dll等文件</li></ul><p>ELF的全称为(Executable and Linkable Format), 无论是那种可执行文件的格式, 其基本概念是相似的</p><hr><br><h3 id="ELF-可重定位目标文件的格式"><a href="#ELF-可重定位目标文件的格式" class="headerlink" title="ELF 可重定位目标文件的格式"></a>ELF 可重定位目标文件的格式</h3><p>ELF header以十六字节的序列开始，该序列描述了生成文件的word长度和字节顺序。<br>而其剩下的部分包含各类信息，其包括  </p><p><strong>ELF头的大小，目标文件的类型，（可执行，共享，可重定位），机器类型（x86-64）,section header table的文件偏移，section header table的条目数量和大小等</strong>   </p><p>不同节的位置和大小都是由section header table描述的，其中目标文件中每一个字节都有一个固定大小的entry。  </p><p><img src="/images/pasted-1.png" alt="upload successful">  </p><p>在section header table和elf文件头中间的就是节， 一般elf文件包含以下几个节  </p><table><thead><tr><th align="left">段   &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;</th><th align="left">存储内容</th></tr></thead><tbody><tr><td align="left">.text</td><td align="left">已经编译的机器代码</td></tr><tr><td align="left">.rodate</td><td align="left">一些只读数据, 通常是字符串或者是一些常量</td></tr><tr><td align="left">.data</td><td align="left">已经初始化的全局变量和静态c变量,以及所有被初始化为0的全局变量或静态变量</td></tr><tr><td align="left">.bss</td><td align="left">未初始化的全局变量和静态变量,  这个节在obj文件中不占用实际的空间, 它仅仅是一个占位符</td></tr><tr><td align="left">.symtab</td><td align="left">一个符号表,它存放在程序中定义和引用的函数和全局变量的信息, 也就是符号表</td></tr><tr><td align="left">.rel.text</td><td align="left">.text节中的位置的列表</td></tr><tr><td align="left">.rel.data</td><td align="left">被模块引用或定义的所有全局变量的重定位信息</td></tr><tr><td align="left">.debug</td><td align="left">调试符号表, 只有以-g选项编译程序时才会得到这张表</td></tr><tr><td align="left">.line</td><td align="left">原始c程序中的行号和.text节中机器指令之间的映射, 只有以-g编译程序时才会得到这张表</td></tr><tr><td align="left">.strtab</td><td align="left">字符串表</td></tr></tbody></table><p>其中后五条见的都比较少, 尤其是在逆向工程中一般都是不含这些信息的  </p><pre><code class="hljs">p.s:.bss段的全称叫(Block Storage Start) 其用于表示未初始化的数据</code></pre><p>除此之外，有些时候还会见到.init_array和.init这样的节，其主要用在so文件中，用来对elf文件进行初始化,对于init_array的设置方法如下:</p><p>在GNU C中 可以在函数后面添加以下语句:  </p><pre><code class="hljs">__attribute__((constructor));__attribute__((destructor));  </code></pre><p> 这个语句可以用来给函数设置属性, 变量属性, 类型属性<br> 而其中的constructor和destructor为构造函数的属性, 这类函数将会在main函数之前被执行, 可见在加了该属性的函数在ida中则会在init_array段被调用</p><p><img src="/images/pasted-2.png" alt="upload successful"></p><p><img src="/images/pasted-3.png" alt="upload successful">  </p><p>在windows平台下，该语法仍然成立</p><p>在constructor中还可以携带参数， 例如  </p><pre><code class="hljs">__attribute__((constructor(100))) void load_init();__attributr__((constructor(102))) void load_file();</code></pre><p>里面的参数代表执行的优先级</p><p>通过这种方法可以实现smc、加壳等加密反调试手法，具体的实验则会在后面的文章中具体展示  </p><p>而关于_<em>attribute_</em> 的相关用法 可以参考<a href="https://www.jianshu.com/p/c8bea3807527">该博客</a>   </p><p>关于其具体的用法在后续的文章中也会给出具体的实验(如果有时间的话做一下, 因为感觉这里面大多数的东西不是很重要)</p>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>逆向工程</tag>
      
      <tag>深入理解计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/02/04/hello-world/"/>
    <url>/2024/02/04/hello-world/</url>
    
    <content type="html"><![CDATA[<p>我会在这里记录我的学习过程</p><p><img src="/images/%E6%8D%A3%E8%9B%8B%E7%8C%AB.gif#pic_center" alt="无敌导弹猫"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>word到底是什么?</title>
    <link href="/2024/02/03/x86%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/02/03/x86%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>一直搞不清楚word到底是什么单位，在ida中也经常会见到DWORD和QWORD这些类型，在我的印象里word一直是两个byte组成的，但是又经常看到说word是根据cpu位数决定的，所以在这里写一篇文章记录一下学习探讨的过程  </p><p>首先，word这个单位是描述计算机进行数据处理的时候一次存取，加工，传送的数据长度，一般与寄存器的长度相同  </p><p>在32位机中1word是32bit<br>在64位机中1word是64bit<br>在16位机中1word是16bit  </p><p>而intel厂商为了可移植性，统一规定了1word为16bit<br>这也是为什么无论32bit的程序还是64bit的程序在ida反编译的结果中都是1 word对应2 byte</p>]]></content>
    
    
    <categories>
      
      <category>汇编</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深入理解计算机系统</tag>
      
      <tag>x86</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安全的ssh登录</title>
    <link href="/2022/12/04/%E5%AE%89%E5%85%A8%E7%9A%84ssh%E7%99%BB%E5%BD%95/"/>
    <url>/2022/12/04/%E5%AE%89%E5%85%A8%E7%9A%84ssh%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>在做开发的时候会经常用到ssh进行远程登录，在以前为了方便都是直接使用密码进行登录的，输入ip，账号密码，瞬间搞定，非常方便</p><p>但是最近在遇到被下挖矿病毒后再也不敢头铁使用密码登录了  </p><p><img src="/./%E5%AE%89%E5%85%A8%E7%9A%84ssh%E7%99%BB%E5%BD%95/00d85d76ed27fc536f4ccffecc03351a.png" alt="alt text">  </p><p>这里被下毒的根本原因还是没有重视安全，在公网环境中使用弱口令作为ssh的登录密码，导致被扫全网自动下毒了，大部分情况下查看日志可以看到很多ssh密码登录的痕迹。   </p><p>所以为了保证环境安全，建议所有暴露在公网上的主机还是使用密钥对登录，并关闭密码登录，这是百利无一害的  </p><p>使用密钥对登录的方法也很简单，首先使用ssh-keygen生成密钥</p><p><code>ssh-keygen -t rsa -b 4096 -C &quot;SudaSec-DevlopTeam&quot;</code>  </p><p>这里几个参数就不讲了，使用该工具之后会询问生成的文件名称以及是否启用私钥密码，这里直接留空按enter就可以了  </p><p>如果使用默认设置一般是在<code>~/&lt;username&gt;/.ssh</code>这个目录下生成的文件，其中带.pub后缀的是公钥，文件长度较大的是私钥，把私钥下载到客户端主机上用于登录  </p><p>除此之外，还需要修改配置, 修改&#x2F;etc&#x2F;ssh&#x2F;sshd_config文件  </p><pre><code class="text">PubkeyAuthentication yesAuthorizedKeysFile      /home/ubuntu/.ssh/id_rsa.pub</code></pre><p>其中这里的PubKeyAuthentication是用于开启公钥登录的，后面的AuthorizedKeysFile用于指定公钥地址  </p><p>然后一般来说就可以登录了，但是在客户端主机上还需要做一件事，那就是修改文件权限，因为不修改的话，ssh会认为这个私钥是不安全的，不会拿来使用</p><p>linux系统修改权限<br><code>chmod 600 /path/to/private_key</code></p><p>windows修改会麻烦一些  </p><p>需要先删除原所属用户：</p><p>右键私钥文件，属性 - 安全 - 高级 - 禁用继承 - 应用</p><p>然后再添加用户</p><p>需求右键id_rsa文件，属性 - 安全 - 更改 - 高级  - 立即查找 - 选择当前Windows用户 - 确认 - 应用  </p><p>之后就可以使用ssh私钥连接了  </p><p>然后可以选择在ssh配置文件中禁用密码登录，减少爆破风险</p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
      <category>开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
